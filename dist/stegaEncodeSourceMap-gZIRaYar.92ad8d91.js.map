{"mappings":"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","sources":["<anon>","node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap-gZIRaYar.js","node_modules/@sanity/client/src/csm/studioPath.ts","node_modules/@sanity/client/src/csm/jsonPath.ts","node_modules/@sanity/client/src/csm/resolveMapping.ts","node_modules/@sanity/client/src/csm/isArray.ts","node_modules/@sanity/client/src/csm/isRecord.ts","node_modules/@sanity/client/src/csm/walkMap.ts","node_modules/@sanity/client/src/stega/encodeIntoResult.ts","node_modules/@sanity/client/src/csm/getPublishedId.ts","node_modules/@sanity/client/src/csm/createEditUrl.ts","node_modules/@sanity/client/src/csm/resolveEditInfo.ts","node_modules/@sanity/client/src/stega/filterDefault.ts","node_modules/@sanity/client/src/stega/stegaEncodeSourceMap.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire1d06\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"9Mmvp\", function(module, exports) {\n\n$parcel$export(module.exports, \"stegaEncodeSourceMap$1\", function () { return $71ea0de495e0dd9b$export$2b977f49f39a7e5e; });\n\nvar $2c7Bo = parcelRequire(\"2c7Bo\");\nconst $71ea0de495e0dd9b$var$reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction $71ea0de495e0dd9b$var$isKeySegment(segment) {\n    if (typeof segment === \"string\") return $71ea0de495e0dd9b$var$reKeySegment.test(segment.trim());\n    return typeof segment === \"object\" && \"_key\" in segment;\n}\nfunction $71ea0de495e0dd9b$var$toString(path) {\n    if (!Array.isArray(path)) throw new Error(\"Path is not an array\");\n    return path.reduce((target, segment, i)=>{\n        const segmentType = typeof segment;\n        if (segmentType === \"number\") return \"\".concat(target, \"[\").concat(segment, \"]\");\n        if (segmentType === \"string\") {\n            const separator = i === 0 ? \"\" : \".\";\n            return \"\".concat(target).concat(separator).concat(segment);\n        }\n        if ($71ea0de495e0dd9b$var$isKeySegment(segment) && segment._key) return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n        if (Array.isArray(segment)) {\n            const [from, to] = segment;\n            return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n        }\n        throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n    }, \"\");\n}\nconst $71ea0de495e0dd9b$var$ESCAPE = {\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\",\n    \"'\": \"\\\\'\",\n    \"\\\\\": \"\\\\\\\\\"\n};\nconst $71ea0de495e0dd9b$var$UNESCAPE = {\n    \"\\\\f\": \"\\f\",\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\t\",\n    \"\\\\'\": \"'\",\n    \"\\\\\\\\\": \"\\\\\"\n};\nfunction $71ea0de495e0dd9b$var$jsonPath(path) {\n    return \"$\".concat(path.map((segment)=>{\n        if (typeof segment === \"string\") {\n            const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match)=>{\n                return $71ea0de495e0dd9b$var$ESCAPE[match];\n            });\n            return \"['\".concat(escapedKey, \"']\");\n        }\n        if (typeof segment === \"number\") return \"[\".concat(segment, \"]\");\n        if (segment._key !== \"\") {\n            const escapedKey = segment._key.replace(/['\\\\]/g, (match)=>{\n                return $71ea0de495e0dd9b$var$ESCAPE[match];\n            });\n            return \"[?(@._key=='\".concat(escapedKey, \"')]\");\n        }\n        return \"[\".concat(segment._index, \"]\");\n    }).join(\"\"));\n}\nfunction $71ea0de495e0dd9b$var$parseJsonPath(path) {\n    const parsed = [];\n    const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n    let match;\n    while((match = parseRe.exec(path)) !== null){\n        if (match[1] !== void 0) {\n            const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m)=>{\n                return $71ea0de495e0dd9b$var$UNESCAPE[m];\n            });\n            parsed.push(key);\n            continue;\n        }\n        if (match[2] !== void 0) {\n            parsed.push(parseInt(match[2], 10));\n            continue;\n        }\n        if (match[3] !== void 0) {\n            const _key = match[3].replace(/\\\\(\\\\')/g, (m)=>{\n                return $71ea0de495e0dd9b$var$UNESCAPE[m];\n            });\n            parsed.push({\n                _key: _key,\n                _index: -1\n            });\n            continue;\n        }\n    }\n    return parsed;\n}\nfunction $71ea0de495e0dd9b$var$jsonPathToStudioPath(path) {\n    return path.map((segment)=>{\n        if (typeof segment === \"string\") return segment;\n        if (typeof segment === \"number\") return segment;\n        if (segment._key !== \"\") return {\n            _key: segment._key\n        };\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction $71ea0de495e0dd9b$var$jsonPathToMappingPath(path) {\n    return path.map((segment)=>{\n        if (typeof segment === \"string\") return segment;\n        if (typeof segment === \"number\") return segment;\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction $71ea0de495e0dd9b$var$resolveMapping(resultPath, csm) {\n    if (!(csm == null ? void 0 : csm.mappings)) return void 0;\n    const resultMappingPath = $71ea0de495e0dd9b$var$jsonPath($71ea0de495e0dd9b$var$jsonPathToMappingPath(resultPath));\n    if (csm.mappings[resultMappingPath] !== void 0) return {\n        mapping: csm.mappings[resultMappingPath],\n        matchedPath: resultMappingPath,\n        pathSuffix: \"\"\n    };\n    const mappings = Object.entries(csm.mappings).filter(([key])=>resultMappingPath.startsWith(key)).sort(([key1], [key2])=>key2.length - key1.length);\n    if (mappings.length == 0) return void 0;\n    const [matchedPath, mapping] = mappings[0];\n    const pathSuffix = resultMappingPath.substring(matchedPath.length);\n    return {\n        mapping: mapping,\n        matchedPath: matchedPath,\n        pathSuffix: pathSuffix\n    };\n}\nfunction $71ea0de495e0dd9b$var$isArray(value) {\n    return value !== null && Array.isArray(value);\n}\nfunction $71ea0de495e0dd9b$var$isRecord(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction $71ea0de495e0dd9b$var$walkMap(value, mappingFn, path = []) {\n    if ($71ea0de495e0dd9b$var$isArray(value)) return value.map((v, idx)=>{\n        if ($71ea0de495e0dd9b$var$isRecord(v)) {\n            const _key = v[\"_key\"];\n            if (typeof _key === \"string\") return $71ea0de495e0dd9b$var$walkMap(v, mappingFn, path.concat({\n                _key: _key,\n                _index: idx\n            }));\n        }\n        return $71ea0de495e0dd9b$var$walkMap(v, mappingFn, path.concat(idx));\n    });\n    if ($71ea0de495e0dd9b$var$isRecord(value)) return Object.fromEntries(Object.entries(value).map(([k, v])=>[\n            k,\n            $71ea0de495e0dd9b$var$walkMap(v, mappingFn, path.concat(k))\n        ]));\n    return mappingFn(value, path);\n}\nfunction $71ea0de495e0dd9b$export$c57d17a25deaf8b7(result, csm, encoder) {\n    return $71ea0de495e0dd9b$var$walkMap(result, (value, path)=>{\n        if (typeof value !== \"string\") return value;\n        const resolveMappingResult = $71ea0de495e0dd9b$var$resolveMapping(path, csm);\n        if (!resolveMappingResult) return value;\n        const { mapping: mapping, matchedPath: matchedPath } = resolveMappingResult;\n        if (mapping.type !== \"value\") return value;\n        if (mapping.source.type !== \"documentValue\") return value;\n        const sourceDocument = csm.documents[mapping.source.document];\n        const sourcePath = csm.paths[mapping.source.path];\n        const matchPathSegments = $71ea0de495e0dd9b$var$parseJsonPath(matchedPath);\n        const sourcePathSegments = $71ea0de495e0dd9b$var$parseJsonPath(sourcePath);\n        const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length));\n        return encoder({\n            sourcePath: fullSourceSegments,\n            sourceDocument: sourceDocument,\n            resultPath: path,\n            value: value\n        });\n    });\n}\nconst $71ea0de495e0dd9b$var$DRAFTS_PREFIX = \"drafts.\";\nfunction $71ea0de495e0dd9b$var$getPublishedId(id) {\n    if (id.startsWith($71ea0de495e0dd9b$var$DRAFTS_PREFIX)) return id.slice($71ea0de495e0dd9b$var$DRAFTS_PREFIX.length);\n    return id;\n}\nfunction $71ea0de495e0dd9b$var$createEditUrl(options) {\n    const { baseUrl: baseUrl, workspace: _workspace = \"default\", tool: _tool = \"default\", id: _id, type: type, path: path } = options;\n    if (!baseUrl) throw new Error(\"baseUrl is required\");\n    if (!path) throw new Error(\"path is required\");\n    if (!_id) throw new Error(\"id is required\");\n    if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) throw new Error(\"baseUrl must not end with a slash\");\n    const workspace = _workspace === \"default\" ? void 0 : _workspace;\n    const tool = _tool === \"default\" ? void 0 : _tool;\n    const id = $71ea0de495e0dd9b$var$getPublishedId(_id);\n    const stringifiedPath = Array.isArray(path) ? $71ea0de495e0dd9b$var$toString($71ea0de495e0dd9b$var$jsonPathToStudioPath(path)) : path;\n    const searchParams = new URLSearchParams({\n        baseUrl: baseUrl,\n        id: id,\n        type: type,\n        path: stringifiedPath\n    });\n    if (workspace) searchParams.set(\"workspace\", workspace);\n    if (tool) searchParams.set(\"tool\", tool);\n    const segments = [\n        baseUrl === \"/\" ? \"\" : baseUrl\n    ];\n    if (workspace) segments.push(workspace);\n    const routerParams = [\n        \"mode=presentation\",\n        \"id=\".concat(id),\n        \"type=\".concat(type),\n        \"path=\".concat(encodeURIComponent(stringifiedPath))\n    ];\n    if (tool) routerParams.push(\"tool=\".concat(tool));\n    segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams));\n    return segments.join(\"/\");\n}\nfunction $71ea0de495e0dd9b$var$resolveStudioBaseRoute(studioUrl) {\n    let baseUrl = typeof studioUrl === \"string\" ? studioUrl : studioUrl.baseUrl;\n    if (baseUrl !== \"/\") baseUrl = baseUrl.replace(/\\/$/, \"\");\n    if (typeof studioUrl === \"string\") return {\n        baseUrl: baseUrl\n    };\n    return {\n        ...studioUrl,\n        baseUrl: baseUrl\n    };\n}\nconst $71ea0de495e0dd9b$var$filterDefault = ({ sourcePath: sourcePath, value: value })=>{\n    if ($71ea0de495e0dd9b$var$isValidDate(value) || $71ea0de495e0dd9b$var$isValidURL(value)) return false;\n    const endPath = sourcePath.at(-1);\n    if (sourcePath.at(-2) === \"slug\" && endPath === \"current\") return false;\n    if (typeof endPath === \"string\" && endPath.startsWith(\"_\")) return false;\n    if (typeof endPath === \"number\" && sourcePath.at(-2) === \"marks\") return false;\n    if (endPath === \"href\" && typeof sourcePath.at(-2) === \"number\" && sourcePath.at(-3) === \"markDefs\") return false;\n    if (endPath === \"style\" || endPath === \"listItem\") return false;\n    if (sourcePath.some((path)=>path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\")) return false;\n    if (typeof endPath === \"string\" && $71ea0de495e0dd9b$var$denylist.has(endPath)) return false;\n    return true;\n};\nconst $71ea0de495e0dd9b$var$denylist = /* @__PURE__ */ new Set([\n    \"color\",\n    \"colour\",\n    \"currency\",\n    \"email\",\n    \"format\",\n    \"gid\",\n    \"hex\",\n    \"href\",\n    \"hsl\",\n    \"hsla\",\n    \"icon\",\n    \"id\",\n    \"index\",\n    \"key\",\n    \"language\",\n    \"layout\",\n    \"link\",\n    \"linkAction\",\n    \"locale\",\n    \"lqip\",\n    \"page\",\n    \"path\",\n    \"ref\",\n    \"rgb\",\n    \"rgba\",\n    \"route\",\n    \"secret\",\n    \"slug\",\n    \"status\",\n    \"tag\",\n    \"template\",\n    \"theme\",\n    \"type\",\n    \"unit\",\n    \"url\",\n    \"username\",\n    \"variant\",\n    \"website\"\n]);\nfunction $71ea0de495e0dd9b$var$isValidDate(dateString) {\n    return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false;\n}\nfunction $71ea0de495e0dd9b$var$isValidURL(url) {\n    try {\n        new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n    } catch  {\n        return false;\n    }\n    return true;\n}\nconst $71ea0de495e0dd9b$var$TRUNCATE_LENGTH = 20;\nfunction $71ea0de495e0dd9b$export$ae58eb1491425156(result, resultSourceMap, config) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const { filter: filter, logger: logger, enabled: enabled } = config;\n    if (!enabled) {\n        const msg = \"config.enabled must be true, don't call this function otherwise\";\n        (_a = logger == null ? void 0 : logger.error) == null || _a.call(logger, \"[@sanity/client/stega]: \".concat(msg), {\n            result: result,\n            resultSourceMap: resultSourceMap,\n            config: config\n        });\n        throw new TypeError(msg);\n    }\n    if (!resultSourceMap) {\n        (_b = logger == null ? void 0 : logger.error) == null || _b.call(logger, \"[@sanity/client/stega]: Missing Content Source Map from response body\", {\n            result: result,\n            resultSourceMap: resultSourceMap,\n            config: config\n        });\n        return result;\n    }\n    if (!config.studioUrl) {\n        const msg = \"config.studioUrl must be defined\";\n        (_c = logger == null ? void 0 : logger.error) == null || _c.call(logger, \"[@sanity/client/stega]: \".concat(msg), {\n            result: result,\n            resultSourceMap: resultSourceMap,\n            config: config\n        });\n        throw new TypeError(msg);\n    }\n    const report = {\n        encoded: [],\n        skipped: []\n    };\n    const resultWithStega = $71ea0de495e0dd9b$export$c57d17a25deaf8b7(result, resultSourceMap, ({ sourcePath: sourcePath, sourceDocument: sourceDocument, resultPath: resultPath, value: value })=>{\n        if ((typeof filter === \"function\" ? filter({\n            sourcePath: sourcePath,\n            resultPath: resultPath,\n            filterDefault: $71ea0de495e0dd9b$var$filterDefault,\n            sourceDocument: sourceDocument,\n            value: value\n        }) : $71ea0de495e0dd9b$var$filterDefault({\n            sourcePath: sourcePath,\n            resultPath: resultPath,\n            filterDefault: $71ea0de495e0dd9b$var$filterDefault,\n            sourceDocument: sourceDocument,\n            value: value\n        })) === false) {\n            if (logger) report.skipped.push({\n                path: $71ea0de495e0dd9b$var$prettyPathForLogging(sourcePath),\n                value: \"\".concat(value.slice(0, $71ea0de495e0dd9b$var$TRUNCATE_LENGTH)).concat(value.length > $71ea0de495e0dd9b$var$TRUNCATE_LENGTH ? \"...\" : \"\"),\n                length: value.length\n            });\n            return value;\n        }\n        if (logger) report.encoded.push({\n            path: $71ea0de495e0dd9b$var$prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, $71ea0de495e0dd9b$var$TRUNCATE_LENGTH)).concat(value.length > $71ea0de495e0dd9b$var$TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n        });\n        const { baseUrl: baseUrl, workspace: workspace, tool: tool } = $71ea0de495e0dd9b$var$resolveStudioBaseRoute(typeof config.studioUrl === \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl);\n        if (!baseUrl) return value;\n        const { _id: id, _type: type } = sourceDocument;\n        return (0, $2c7Bo.b)(value, {\n            origin: \"sanity.io\",\n            href: $71ea0de495e0dd9b$var$createEditUrl({\n                baseUrl: baseUrl,\n                workspace: workspace,\n                tool: tool,\n                id: id,\n                type: type,\n                path: sourcePath\n            })\n        }, // We use custom logic to determine if we should skip encoding\n        false);\n    });\n    if (logger) {\n        const isSkipping = report.skipped.length;\n        const isEncoding = report.encoded.length;\n        if (isSkipping || isEncoding) {\n            (_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null || _d(\"[@sanity/client/stega]: Encoding source map into result\");\n            (_e = logger.log) == null || _e.call(logger, \"[@sanity/client/stega]: Paths encoded: \".concat(report.encoded.length, \", skipped: \").concat(report.skipped.length));\n        }\n        if (report.encoded.length > 0) {\n            (_f = logger == null ? void 0 : logger.log) == null || _f.call(logger, \"[@sanity/client/stega]: Table of encoded paths\");\n            (_g = (logger == null ? void 0 : logger.table) || logger.log) == null || _g(report.encoded);\n        }\n        if (report.skipped.length > 0) {\n            const skipped = /* @__PURE__ */ new Set();\n            for (const { path: path } of report.skipped)skipped.add(path.replace($71ea0de495e0dd9b$var$reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n            (_h = logger == null ? void 0 : logger.log) == null || _h.call(logger, \"[@sanity/client/stega]: List of skipped paths\", [\n                ...skipped.values()\n            ]);\n        }\n        if (isSkipping || isEncoding) (_i = logger == null ? void 0 : logger.groupEnd) == null || _i.call(logger);\n    }\n    return resultWithStega;\n}\nfunction $71ea0de495e0dd9b$var$prettyPathForLogging(path) {\n    return $71ea0de495e0dd9b$var$toString($71ea0de495e0dd9b$var$jsonPathToStudioPath(path));\n}\nvar $71ea0de495e0dd9b$export$2b977f49f39a7e5e = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    stegaEncodeSourceMap: $71ea0de495e0dd9b$export$ae58eb1491425156\n});\n\n});\n\n\n//# sourceMappingURL=stegaEncodeSourceMap-gZIRaYar.92ad8d91.js.map\n","import { b } from './browserMiddleware-zDVeirri.js';\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  if (typeof segment === \"string\") {\n    return reKeySegment.test(segment.trim());\n  }\n  return typeof segment === \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path)) {\n    throw new Error(\"Path is not an array\");\n  }\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\") {\n      return \"\".concat(target, \"[\").concat(segment, \"]\");\n    }\n    if (segmentType === \"string\") {\n      const separator = i === 0 ? \"\" : \".\";\n      return \"\".concat(target).concat(separator).concat(segment);\n    }\n    if (isKeySegment(segment) && segment._key) {\n      return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n    }\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n    }\n    throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n  }, \"\");\n}\n\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n};\nconst UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": \"\\n\",\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return \"$\".concat(path.map((segment) => {\n    if (typeof segment === \"string\") {\n      const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n        return ESCAPE[match];\n      });\n      return \"['\".concat(escapedKey, \"']\");\n    }\n    if (typeof segment === \"number\") {\n      return \"[\".concat(segment, \"]\");\n    }\n    if (segment._key !== \"\") {\n      const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n        return ESCAPE[match];\n      });\n      return \"[?(@._key=='\".concat(escapedKey, \"')]\");\n    }\n    return \"[\".concat(segment._index, \"]\");\n  }).join(\"\"));\n}\nfunction parseJsonPath(path) {\n  const parsed = [];\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m];\n      });\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m];\n      });\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (segment._key !== \"\") {\n      return { _key: segment._key };\n    }\n    if (segment._index !== -1) {\n      return segment._index;\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (segment._index !== -1) {\n      return segment._index;\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\n\nfunction resolveMapping(resultPath, csm) {\n  if (!(csm == null ? void 0 : csm.mappings)) {\n    return void 0;\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  }\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0) {\n    return void 0;\n  }\n  const [matchedPath, mapping] = mappings[0];\n  const pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\n\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\n\nfunction isRecord(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v[\"_key\"];\n        if (typeof _key === \"string\") {\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n        }\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  }\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\n\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult) {\n      return value;\n    }\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\") {\n      return value;\n    }\n    if (mapping.source.type !== \"documentValue\") {\n      return value;\n    }\n    const sourceDocument = csm.documents[mapping.source.document];\n    const sourcePath = csm.paths[mapping.source.path];\n    const matchPathSegments = parseJsonPath(matchedPath);\n    const sourcePathSegments = parseJsonPath(sourcePath);\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\n\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length);\n  }\n  return id;\n}\n\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path\n  } = options;\n  if (!baseUrl) {\n    throw new Error(\"baseUrl is required\");\n  }\n  if (!path) {\n    throw new Error(\"path is required\");\n  }\n  if (!_id) {\n    throw new Error(\"id is required\");\n  }\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) {\n    throw new Error(\"baseUrl must not end with a slash\");\n  }\n  const workspace = _workspace === \"default\" ? void 0 : _workspace;\n  const tool = _tool === \"default\" ? void 0 : _tool;\n  const id = getPublishedId(_id);\n  const stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path;\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  if (workspace) {\n    searchParams.set(\"workspace\", workspace);\n  }\n  if (tool) {\n    searchParams.set(\"tool\", tool);\n  }\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  if (workspace) {\n    segments.push(workspace);\n  }\n  const routerParams = [\n    \"mode=presentation\",\n    \"id=\".concat(id),\n    \"type=\".concat(type),\n    \"path=\".concat(encodeURIComponent(stringifiedPath))\n  ];\n  if (tool) {\n    routerParams.push(\"tool=\".concat(tool));\n  }\n  segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams));\n  return segments.join(\"/\");\n}\n\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl === \"string\" ? studioUrl : studioUrl.baseUrl;\n  if (baseUrl !== \"/\") {\n    baseUrl = baseUrl.replace(/\\/$/, \"\");\n  }\n  if (typeof studioUrl === \"string\") {\n    return { baseUrl };\n  }\n  return { ...studioUrl, baseUrl };\n}\n\nconst filterDefault = ({ sourcePath, value }) => {\n  if (isValidDate(value) || isValidURL(value)) {\n    return false;\n  }\n  const endPath = sourcePath.at(-1);\n  if (sourcePath.at(-2) === \"slug\" && endPath === \"current\") {\n    return false;\n  }\n  if (typeof endPath === \"string\" && endPath.startsWith(\"_\")) {\n    return false;\n  }\n  if (typeof endPath === \"number\" && sourcePath.at(-2) === \"marks\") {\n    return false;\n  }\n  if (endPath === \"href\" && typeof sourcePath.at(-2) === \"number\" && sourcePath.at(-3) === \"markDefs\") {\n    return false;\n  }\n  if (endPath === \"style\" || endPath === \"listItem\") {\n    return false;\n  }\n  if (sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  )) {\n    return false;\n  }\n  if (typeof endPath === \"string\" && denylist.has(endPath)) {\n    return false;\n  }\n  return true;\n};\nconst denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return false;\n  }\n  return true;\n}\n\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, \"[@sanity/client/stega]: \".concat(msg), { result, resultSourceMap, config });\n    throw new TypeError(msg);\n  }\n  if (!resultSourceMap) {\n    (_b = logger == null ? void 0 : logger.error) == null ? void 0 : _b.call(logger, \"[@sanity/client/stega]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    });\n    return result;\n  }\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    (_c = logger == null ? void 0 : logger.error) == null ? void 0 : _c.call(logger, \"[@sanity/client/stega]: \".concat(msg), { result, resultSourceMap, config });\n    throw new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  };\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter === \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === false) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n          });\n        }\n        return value;\n      }\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n          length: value.length\n        });\n      }\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl === \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl)\n        return value;\n      const { _id: id, _type: type } = sourceDocument;\n      return b(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        false\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length;\n    const isEncoding = report.encoded.length;\n    if (isSkipping || isEncoding) {\n      (_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null ? void 0 : _d(\n        \"[@sanity/client/stega]: Encoding source map into result\"\n      );\n      (_e = logger.log) == null ? void 0 : _e.call(\n        logger,\n        \"[@sanity/client/stega]: Paths encoded: \".concat(report.encoded.length, \", skipped: \").concat(report.skipped.length)\n      );\n    }\n    if (report.encoded.length > 0) {\n      (_f = logger == null ? void 0 : logger.log) == null ? void 0 : _f.call(logger, \"[@sanity/client/stega]: Table of encoded paths\");\n      (_g = (logger == null ? void 0 : logger.table) || logger.log) == null ? void 0 : _g(report.encoded);\n    }\n    if (report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped) {\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      }\n      (_h = logger == null ? void 0 : logger.log) == null ? void 0 : _h.call(logger, \"[@sanity/client/stega]: List of skipped paths\", [...skipped.values()]);\n    }\n    if (isSkipping || isEncoding) {\n      (_i = logger == null ? void 0 : logger.groupEnd) == null ? void 0 : _i.call(logger);\n    }\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\n\nvar stegaEncodeSourceMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap: stegaEncodeSourceMap\n});\n\nexport { encodeIntoResult, stegaEncodeSourceMap, stegaEncodeSourceMap$1 };\n//# sourceMappingURL=stegaEncodeSourceMap-gZIRaYar.js.map\n","/** @alpha */\nexport type KeyedSegment = {_key: string}\n\n/** @alpha */\nexport type IndexTuple = [number | '', number | '']\n\n/** @alpha */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/** @alpha */\nexport type Path = PathSegment[]\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n/** @internal */\nexport const reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n\n/** @internal */\nexport function get<Result = unknown, Fallback = unknown>(\n  obj: unknown,\n  path: Path | string,\n  defaultVal?: Fallback,\n): Result | typeof defaultVal {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Result)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc as Result\n}\n\n/** @alpha */\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\n/** @alpha */\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(parsePathSegment)\n}\n\nfunction parsePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction parseIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction parseKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction parseIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n","import * as studioPath from './studioPath'\nimport type {\n  ContentSourceMapParsedPath,\n  ContentSourceMapParsedPathKeyedSegment,\n  ContentSourceMapPaths,\n  Path,\n} from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/**\n * @internal\n */\nexport function jsonPath(path: ContentSourceMapParsedPath): ContentSourceMapPaths[number] {\n  return `$${path\n    .map((segment) => {\n      if (typeof segment === 'string') {\n        const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      if (typeof segment === 'number') {\n        return `[${segment}]`\n      }\n\n      if (segment._key !== '') {\n        const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `[?(@._key=='${escapedKey}')]`\n      }\n\n      return `[${segment._index}]`\n    })\n    .join('')}`\n}\n\n/**\n * @internal\n */\nexport function parseJsonPath(path: ContentSourceMapPaths[number]): ContentSourceMapParsedPath {\n  const parsed: ContentSourceMapParsedPath = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n\n    if (match[3] !== undefined) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push({\n        _key,\n        _index: -1,\n      })\n      continue\n    }\n  }\n\n  return parsed\n}\n\n/**\n * @internal\n */\nexport function jsonPathToStudioPath(path: ContentSourceMapParsedPath): Path {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._key !== '') {\n      return {_key: segment._key}\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\n/**\n * @internal\n */\nexport function studioPathToJsonPath(path: Path | string): ContentSourceMapParsedPath {\n  const parsedPath = typeof path === 'string' ? studioPath.fromString(path) : path\n\n  return parsedPath.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (Array.isArray(segment)) {\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`)\n    }\n\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment\n    }\n\n    if (segment._key) {\n      return {_key: segment._key, _index: -1}\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\nfunction isContentSourceMapParsedPathKeyedSegment(\n  segment: studioPath.PathSegment | ContentSourceMapParsedPath[number],\n): segment is ContentSourceMapParsedPathKeyedSegment {\n  return typeof segment === 'object' && '_key' in segment && '_index' in segment\n}\n\n/**\n * @internal\n */\nexport function jsonPathToMappingPath(path: ContentSourceMapParsedPath): (string | number)[] {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n","import {jsonPath, jsonPathToMappingPath} from './jsonPath'\nimport type {ContentSourceMap, ContentSourceMapMapping, ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolveMapping(\n  resultPath: ContentSourceMapParsedPath,\n  csm?: ContentSourceMap,\n):\n  | {\n      mapping: ContentSourceMapMapping\n      matchedPath: string\n      pathSuffix: string\n    }\n  | undefined {\n  if (!csm?.mappings) {\n    return undefined\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath))\n\n  if (csm.mappings[resultMappingPath] !== undefined) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: '',\n    }\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultMappingPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultMappingPath.substring(matchedPath.length)\n  return {mapping, matchedPath, pathSuffix}\n}\n","/** @internal */\nexport function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n","/** @internal */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n","import {isArray} from './isArray'\nimport {isRecord} from './isRecord'\nimport type {ContentSourceMapParsedPath, WalkMapFn} from './types'\n\n/**\n * generic way to walk a nested object or array and apply a mapping function to each value\n * @internal\n */\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: ContentSourceMapParsedPath = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v['_key']\n        if (typeof _key === 'string') {\n          return walkMap(v, mappingFn, path.concat({_key, _index: idx}))\n        }\n      }\n\n      return walkMap(v, mappingFn, path.concat(idx))\n    })\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n","import {parseJsonPath} from '../csm/jsonPath'\nimport {resolveMapping} from '../csm/resolveMapping'\nimport type {ContentSourceMap} from '../csm/types'\nimport {walkMap} from '../csm/walkMap'\nimport type {Encoder} from './types'\n\n/**\n * @internal\n */\nexport function encodeIntoResult<Result>(\n  result: Result,\n  csm: ContentSourceMap,\n  encoder: Encoder,\n): Result {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const {mapping, matchedPath} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = csm.documents[mapping.source.document!]\n    const sourcePath = csm.paths[mapping.source.path]\n\n    const matchPathSegments = parseJsonPath(matchedPath)\n    const sourcePathSegments = parseJsonPath(sourcePath)\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length))\n\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value,\n    })\n  }) as Result\n}\n","export const DRAFTS_PREFIX = 'drafts.'\n\n/** @internal */\nexport function getPublishedId(id: string): string {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length)\n  }\n\n  return id\n}\n","import {getPublishedId} from './getPublishedId'\nimport {jsonPathToStudioPath} from './jsonPath'\nimport * as studioPath from './studioPath'\nimport type {CreateEditUrlOptions, EditIntentUrl, StudioBaseUrl} from './types'\n\n/** @internal */\nexport function createEditUrl(options: CreateEditUrlOptions): `${StudioBaseUrl}${EditIntentUrl}` {\n  const {\n    baseUrl,\n    workspace: _workspace = 'default',\n    tool: _tool = 'default',\n    id: _id,\n    type,\n    path,\n  } = options\n\n  if (!baseUrl) {\n    throw new Error('baseUrl is required')\n  }\n  if (!path) {\n    throw new Error('path is required')\n  }\n  if (!_id) {\n    throw new Error('id is required')\n  }\n  if (baseUrl !== '/' && baseUrl.endsWith('/')) {\n    throw new Error('baseUrl must not end with a slash')\n  }\n\n  const workspace = _workspace === 'default' ? undefined : _workspace\n  const tool = _tool === 'default' ? undefined : _tool\n  // eslint-disable-next-line no-warning-comments\n  // @TODO allow passing draft prefixed IDs, to better open the right perspective mode\n  const id = getPublishedId(_id)\n  const stringifiedPath = Array.isArray(path)\n    ? studioPath.toString(jsonPathToStudioPath(path))\n    : path\n\n  // eslint-disable-next-line no-warning-comments\n  // @TODO Using searchParams as a temporary workaround until `@sanity/overlays` can decode state from the path reliably\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath,\n  })\n  if (workspace) {\n    searchParams.set('workspace', workspace)\n  }\n  if (tool) {\n    searchParams.set('tool', tool)\n  }\n\n  const segments = [baseUrl === '/' ? '' : baseUrl]\n  if (workspace) {\n    segments.push(workspace)\n  }\n  const routerParams = [\n    'mode=presentation',\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`,\n  ]\n  if (tool) {\n    routerParams.push(`tool=${tool}`)\n  }\n  segments.push('intent', 'edit', `${routerParams.join(';')}?${searchParams}`)\n  return segments.join('/') as unknown as `${StudioBaseUrl}${EditIntentUrl}`\n}\n","import {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport type {\n  CreateEditUrlOptions,\n  ResolveEditInfoOptions,\n  StudioBaseRoute,\n  StudioBaseUrl,\n  StudioUrl,\n} from './types'\n\n/** @internal */\nexport function resolveEditInfo(options: ResolveEditInfoOptions): CreateEditUrlOptions | undefined {\n  const {resultSourceMap: csm, resultPath} = options\n  const {mapping, pathSuffix} = resolveMapping(resultPath, csm) || {}\n\n  if (!mapping) {\n    // console.warn('no mapping for path', { path: resultPath, sourceMap: csm })\n    return undefined\n  }\n\n  if (mapping.source.type === 'literal') {\n    return undefined\n  }\n\n  if (mapping.source.type === 'unknown') {\n    return undefined\n  }\n\n  const sourceDoc = csm.documents[mapping.source.document]\n  const sourcePath = csm.paths[mapping.source.path]\n\n  if (sourceDoc && sourcePath) {\n    const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n      typeof options.studioUrl === 'function' ? options.studioUrl(sourceDoc) : options.studioUrl,\n    )\n    if (!baseUrl) return undefined\n    const {_id, _type} = sourceDoc\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n    } satisfies CreateEditUrlOptions\n  }\n\n  return undefined\n}\n\n/** @internal */\nexport function resolveStudioBaseRoute(studioUrl: StudioUrl): StudioBaseRoute {\n  let baseUrl: StudioBaseUrl = typeof studioUrl === 'string' ? studioUrl : studioUrl.baseUrl\n  if (baseUrl !== '/') {\n    baseUrl = baseUrl.replace(/\\/$/, '')\n  }\n  if (typeof studioUrl === 'string') {\n    return {baseUrl}\n  }\n  return {...studioUrl, baseUrl}\n}\n","import type {FilterDefault} from './types'\n\nexport const filterDefault: FilterDefault = ({sourcePath, value}) => {\n  // Skips encoding on URL or Date strings, similar to the `skip: 'auto'` parameter in vercelStegaCombine()\n  if (isValidDate(value) || isValidURL(value)) {\n    return false\n  }\n\n  const endPath = sourcePath.at(-1)\n  // Never encode slugs\n  if (sourcePath.at(-2) === 'slug' && endPath === 'current') {\n    return false\n  }\n\n  // Skip underscored keys, needs better heuristics but it works for now\n  if (typeof endPath === 'string' && endPath.startsWith('_')) {\n    return false\n  }\n\n  /**\n   * Best effort infer Portable Text paths that should not be encoded.\n   * Nothing is for certain, and the below implementation may cause paths that aren't Portable Text and otherwise be safe to encode to be skipped.\n   * However, that's ok as userland can always opt-in with the `encodeSourceMapAtPath` option and mark known safe paths as such, which will override this heuristic.\n   */\n  // If the path ends in marks[number] it's likely a PortableTextSpan: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#LL154C16-L154C16\n  if (typeof endPath === 'number' && sourcePath.at(-2) === 'marks') {\n    return false\n  }\n  // Or if it's [number].markDefs[number].href it's likely a PortableTextLink: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L163\n  if (\n    endPath === 'href' &&\n    typeof sourcePath.at(-2) === 'number' &&\n    sourcePath.at(-3) === 'markDefs'\n  ) {\n    return false\n  }\n  // Otherwise we have to deal with special properties of PortableTextBlock, and we can't confidently know if it's actually a `_type: 'block'` array item or not.\n  // All we know is that if it is indeed a block, and we encode the strings on these keys it'll for sure break the PortableText rendering and thus we skip encoding.\n  // https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L48-L58\n  if (endPath === 'style' || endPath === 'listItem') {\n    return false\n  }\n\n  // Don't encode into anything that is suggested it'll render for SEO in meta tags\n  if (\n    sourcePath.some(\n      (path) => path === 'meta' || path === 'metadata' || path === 'openGraph' || path === 'seo',\n    )\n  ) {\n    return false\n  }\n\n  // Finally, we ignore a bunch of paths that are typically used for page building\n  if (typeof endPath === 'string' && denylist.has(endPath)) {\n    return false\n  }\n\n  return true\n}\n\nconst denylist = new Set([\n  'color',\n  'colour',\n  'currency',\n  'email',\n  'format',\n  'gid',\n  'hex',\n  'href',\n  'hsl',\n  'hsla',\n  'icon',\n  'id',\n  'index',\n  'key',\n  'language',\n  'layout',\n  'link',\n  'linkAction',\n  'locale',\n  'lqip',\n  'page',\n  'path',\n  'ref',\n  'rgb',\n  'rgba',\n  'route',\n  'secret',\n  'slug',\n  'status',\n  'tag',\n  'template',\n  'theme',\n  'type',\n  'unit',\n  'url',\n  'username',\n  'variant',\n  'website',\n])\n\nfunction isValidDate(dateString: string) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false\n}\n\nfunction isValidURL(url: string) {\n  try {\n    new URL(url, url.startsWith('/') ? 'https://acme.com' : undefined)\n  } catch {\n    return false\n  }\n  return true\n}\n","import {vercelStegaCombine} from '@vercel/stega'\n\nimport {createEditUrl} from '../csm/createEditUrl'\nimport {jsonPathToStudioPath} from '../csm/jsonPath'\nimport {resolveStudioBaseRoute} from '../csm/resolveEditInfo'\nimport {reKeySegment, toString as studioPathToString} from '../csm/studioPath'\nimport {encodeIntoResult} from './encodeIntoResult'\nimport {filterDefault} from './filterDefault'\nimport {ContentSourceMap, ContentSourceMapParsedPath, InitializedStegaConfig} from './types'\n\nconst TRUNCATE_LENGTH = 20\n\n/**\n * Uses `@vercel/stega` to embed edit info JSON into strings in your query result.\n * The JSON payloads are added using invisible characters so they don't show up visually.\n * The edit info is generated from the Content Source Map (CSM) that is returned from Sanity for the query.\n * @public\n */\nexport function stegaEncodeSourceMap<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  config: InitializedStegaConfig,\n): Result {\n  const {filter, logger, enabled} = config\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\"\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  if (!resultSourceMap) {\n    logger?.error?.('[@sanity/client/stega]: Missing Content Source Map from response body', {\n      result,\n      resultSourceMap,\n      config,\n    })\n    return result\n  }\n\n  if (!config.studioUrl) {\n    const msg = 'config.studioUrl must be defined'\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  const report: Record<'encoded' | 'skipped', {path: string; length: number; value: string}[]> = {\n    encoded: [],\n    skipped: [],\n  }\n\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({sourcePath, sourceDocument, resultPath, value}) => {\n      // Allow userland to control when to opt-out of encoding\n      if (\n        (typeof filter === 'function'\n          ? filter({sourcePath, resultPath, filterDefault, sourceDocument, value})\n          : filterDefault({sourcePath, resultPath, filterDefault, sourceDocument, value})) === false\n      ) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: `${value.slice(0, TRUNCATE_LENGTH)}${\n              value.length > TRUNCATE_LENGTH ? '...' : ''\n            }`,\n            length: value.length,\n          })\n        }\n        return value\n      }\n\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? '...' : ''}`,\n          length: value.length,\n        })\n      }\n\n      const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n        typeof config.studioUrl === 'function'\n          ? config.studioUrl(sourceDocument)\n          : config.studioUrl!,\n      )\n      if (!baseUrl) return value\n      const {_id: id, _type: type} = sourceDocument\n\n      return vercelStegaCombine(\n        value,\n        {\n          origin: 'sanity.io',\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n          }),\n        },\n        // We use custom logic to determine if we should skip encoding\n        false,\n      )\n    },\n  )\n\n  if (logger) {\n    const isSkipping = report.skipped.length\n    const isEncoding = report.encoded.length\n    if (isSkipping || isEncoding) {\n      ;(logger?.groupCollapsed || logger.log)?.(\n        '[@sanity/client/stega]: Encoding source map into result',\n      )\n      logger.log?.(\n        `[@sanity/client/stega]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`,\n      )\n    }\n    if (report.encoded.length > 0) {\n      logger?.log?.(`[@sanity/client/stega]: Table of encoded paths`)\n      ;(logger?.table || logger.log)?.(report.encoded)\n    }\n    if (report.skipped.length > 0) {\n      const skipped = new Set<string>()\n      for (const {path} of report.skipped) {\n        skipped.add(path.replace(reKeySegment, '0').replace(/\\[\\d+\\]/g, '[]'))\n      }\n      logger?.log?.(`[@sanity/client/stega]: List of skipped paths`, [...skipped.values()])\n    }\n\n    if (isSkipping || isEncoding) {\n      logger?.groupEnd?.()\n    }\n  }\n\n  return resultWithStega\n}\n\nfunction prettyPathForLogging(path: ContentSourceMapParsedPath): string {\n  return studioPathToString(jsonPathToStudioPath(path))\n}\n"],"names":["parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","Object","defineProperty","get","$71ea0de495e0dd9b$export$2b977f49f39a7e5e","set","s","enumerable","configurable","$2c7Bo","$71ea0de495e0dd9b$var$reKeySegment","$71ea0de495e0dd9b$var$toString","path","Array","isArray","Error","reduce","target","segment","i","segmentType","concat","$71ea0de495e0dd9b$var$isKeySegment","test","trim","_key","from","to","JSON","stringify","$71ea0de495e0dd9b$var$ESCAPE","$71ea0de495e0dd9b$var$UNESCAPE","$71ea0de495e0dd9b$var$parseJsonPath","match","parsed","parseRe","exec","key","replace","m","push","parseInt","_index","$71ea0de495e0dd9b$var$jsonPathToStudioPath","map","$71ea0de495e0dd9b$var$isRecord","value","$71ea0de495e0dd9b$var$DRAFTS_PREFIX","$71ea0de495e0dd9b$var$filterDefault","sourcePath","Date","parse","$71ea0de495e0dd9b$var$isValidURL","url","URL","startsWith","endPath","at","some","$71ea0de495e0dd9b$var$denylist","has","Set","freeze","__proto__","stegaEncodeSourceMap","result","resultSourceMap","config","_a","_b","_c","_d","_e","_f","_g","_h","_i","encoder","filter","logger","enabled","msg","error","call","TypeError","studioUrl","report","encoded","skipped","resultWithStega","sourceDocument","resultPath","baseUrl","filterDefault","slice","length","workspace","tool","_id","id","_type","type","b","origin","href","$71ea0de495e0dd9b$var$createEditUrl","options","_workspace","_tool","endsWith","stringifiedPath","searchParams","URLSearchParams","segments","routerParams","encodeURIComponent","join","$71ea0de495e0dd9b$var$walkMap","mappingFn","v","idx","fromEntries","entries","k","resolveMappingResult","$71ea0de495e0dd9b$var$resolveMapping","csm","mappings","resultMappingPath","escapedKey","mapping","matchedPath","pathSuffix","sort","key1","key2","substring","source","documents","document","paths","matchPathSegments","sourcePathSegments","isSkipping","isEncoding","groupCollapsed","log","table","add","values","groupEnd","studioPath.toString","vercelStegaCombine","studioPathToString"],"version":3,"file":"stegaEncodeSourceMap-gZIRaYar.92ad8d91.js.map"}