{"mappings":"A,I,E,A,C,E,C,E,A,C,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,C,E,iB,E,Q,A,E,Q,S,C,C,C,E,O,c,C,E,O,C,yB,C,I,W,O,C,E,I,K,E,W,C,E,a,C,C,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SEea,EAAe,2BA6ErB,SAAS,EAAS,CAAoB,EAC3C,GAAI,CAAC,MAAM,OAAQ,CAAA,GACX,MAAA,AAAI,MAAM,wBAGlB,OAAO,EAAK,MAAA,CAAe,SAAC,CAAA,CAAQ,CAAA,CAAS,CAA7C,EACE,IAAM,EAAc,AAAO,KAAA,IAAA,EAAA,YAAP,AAAA,CAAA,EAAA,EAAA,CAAO,AAAP,EAAO,GAC3B,GAAI,AAAgB,WAAhB,EACK,MAAA,GAAG,MAAM,CAAA,EAAA,KAAI,MAAO,CAAA,EAAA,KAG7B,GAAI,AAAgB,WAAhB,EAEK,MAAA,GAAG,MAAA,CAAA,GAAS,MAAY,CADb,AAAM,IAAN,EAAU,GAAK,KACF,MAAA,CAAA,GAGjC,GAAI,AAnFF,CAAA,AAAA,AAAmB,UAAnB,OAmFe,EAlFV,EAAa,IAAA,CAAK,AAkFR,EAlFgB,IAAA,IAG5B,AAAmB,UAAnB,OA+EY,GA/EmB,SA+EnB,CAnFf,GAmF2B,EAAQ,IAAM,CACzC,MAAO,GAAG,MAAA,CAAA,EAAM,YAAW,MAAA,CAAA,EAAQ,IAAI,CAAA,MAGrC,GAAA,MAAM,OAAQ,CAAA,GAAU,CACpB,IAAa,EAAA,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,EAAA,GAAZ,EAAY,CAAA,CAAA,EAAA,CAAN,EAAM,CAAb,CAAA,EAAA,CACN,MAAO,GAAG,MAAA,CAAA,EAAM,KAAI,MAAA,CAAA,EAAI,KAAI,MAAE,CAAA,EAAA,IAAA,CAGhC,MAAM,AAAI,MAAM,6BAA8B,MAAA,CAAA,KAAK,SAAU,CAAA,GAAQ,KAAI,EACxE,GACL,CC/GA,IAAM,EAAiC,CACrC,KAAM,MACN,KAAM,MACN,KAAM,MACN,IAAM,MACN,IAAK,MACL,KAAM,MACR,EAEM,EAAmC,CACvC,MAAO,KACP,MAAO,KACP,MAAO,KACP,MAAO,IACP,MAAO,IACP,OAAQ,IACV,EAkCO,SAAS,EAAc,CAAiE,EAM7F,IALA,IAGI,EAHE,EAAqC,EAAC,CAEtC,EAAU,oDAGR,AAAgC,OAAhC,CAAA,EAAQ,EAAQ,IAAK,CAAA,EAAA,GAAiB,CACxC,GAAA,AAAa,KAAW,IAAxB,CAAA,CAAM,EAAC,CAAiB,CAC1B,IAAM,EAAM,CAAM,CAAA,EAAC,CAAE,OAAQ,CAAA,oBAAqB,SAAC,CAAnD,EACE,OAAO,CAAA,CAAS,EAAC,AAAA,GAGnB,EAAO,IAAA,CAAK,GACZ,QAAA,CAGE,GAAA,AAAa,KAAW,IAAxB,CAAA,CAAM,EAAC,CAAiB,CAC1B,EAAO,IAAA,CAAK,SAAS,CAAA,CAAM,EAAC,CAAG,KAC/B,QAAA,CAGE,GAAA,AAAa,KAAW,IAAxB,CAAA,CAAM,EAAC,CAAiB,CAC1B,IAAM,EAAO,CAAM,CAAA,EAAC,CAAE,OAAQ,CAAA,WAAY,SAAC,CAA3C,EACE,OAAO,CAAA,CAAS,EAAC,AAAA,GAGnB,EAAO,IAAK,CAAA,CACV,KAAA,EACA,OAAQ,EAAA,GAEV,QAAA,CACF,CAGK,OAAA,CACT,CAKO,SAAS,EAAqB,CAAwC,EACpE,OAAA,EAAK,GAAI,CAAA,SAAC,CAAV,EACD,GAAmB,UAAnB,OAAO,GAIP,AAAmB,UAAnB,OAAO,EAHF,OAAA,EAOL,GAAA,AAAiB,KAAjB,EAAQ,IAAA,CACH,MAAA,CAAC,KAAM,EAAQ,IAAI,AAAA,EAGxB,GAAA,AAAmB,KAAnB,EAAQ,MAAA,CACV,OAAO,EAAQ,MAAA,AAGjB,OAAM,AAAI,MAAM,mBAAmB,MAAK,CAAA,KAAA,SAAA,CAAU,IAAU,EAEhE,CGrHO,SAAS,EAAS,CAAkD,EAClE,MAAA,AAAiB,UAAjB,OAAO,GAAsB,AAAU,OAAV,CACtC,CGHO,IAAM,EAAgB,UGEhB,EAA+B,SAArC,CAAA,EAAuC,IAAA,EAAA,EAAA,UAAA,CAAY,EAAA,EAAA,KAAZ,CAE5C,GAkGO,qBAAqB,IAAA,CAlGZ,IAkGuC,KAAK,KAAA,CAlG5C,IAAU,AAqG5B,SAAoB,CAAa,EAC3B,GAAA,CACF,IAAI,IAAI,EAAK,EAAI,UAAA,CAAW,KAAO,mBAAqB,KAAS,EAAA,CAC3D,MAAA,EAAA,CACC,MAAA,CAAA,CAAA,CAEF,MAAA,CAAA,CACT,EA5GuC,GAC5B,MAAA,CAAA,EAGH,IAAA,EAAU,EAAW,EAAA,CAAG,YAEJ,SAAtB,EAAW,EAAG,CAAA,KAAkB,AAAY,YAAZ,GAKhC,AAAmB,UAAnB,OAAO,GAAwB,EAAQ,UAAA,CAAW,MAUlD,AAAmB,UAAnB,OAAO,GAAwB,AAAsB,UAAtB,EAAW,EAAG,CAAA,KAK/C,AAAY,SAAZ,GACA,AAA6B,UAA7B,OAAO,EAAW,EAAG,CAAA,KACrB,AAAsB,aAAtB,EAAW,EAAA,CAAG,KAOZ,AAAY,UAAZ,GAAuB,AAAY,aAAZ,GAMzB,EAAW,IAAA,CACT,SAAC,CAFL,EAEc,MAAA,AAAS,SAAT,GAAmB,AAAS,aAAT,GAAuB,AAAS,cAAT,GAAwB,AAAS,QAAT,CAGvE,IAIL,AAAmB,UAAnB,OAAO,GAAwB,EAAS,GAAA,CAAI,GAKlD,EAEM,EAAA,IAAe,IAAI,CACvB,QACA,SACA,WACA,QACA,SACA,MACA,MACA,OACA,MACA,OACA,OACA,KACA,QACA,MACA,WACA,SACA,OACA,aACA,SACA,OACA,OACA,OACA,MACA,MACA,OACA,QACA,SACA,OACA,SACA,MACA,WACA,QACA,OACA,OACA,MACA,WACA,UACA,UACD,E,E,O,M,C,C,U,K,qBCjFe,SACd,CACA,CAAA,CAAA,CACA,CACQ,EACR,IAAO,EAA2B,EAA3B,MAAA,CAAQ,EAAmB,EAAnB,MAAA,CACf,GAAI,CAD8B,EAAX,OAAvB,CACc,CACZ,IAAM,EAAM,iEAEN,OADN,AAAA,MAAA,CAAA,EAAA,AAAA,MAAA,EAAA,KAAA,EAAA,EAAQ,KAAA,AAAA,GAAQ,EAAA,IAAA,CAAA,EAAA,2BAA2B,MAAA,CAAA,GAAO,CAAC,OAAA,EAAQ,gBAAA,EAAiB,OAAA,CAAM,GAC5E,AAAI,UAAU,EAAG,CAGzB,GAAI,CAAC,EAMI,OALC,AAAR,MAAQ,CAAA,EAAA,AAAA,MAAA,EAAA,KAAA,EAAA,EAAA,KAAA,AAAA,GAAR,EAAA,IAAA,CAAA,EAAgB,wEAAyE,CACvF,OAAA,EACA,gBAAA,EACA,OAAA,CAAA,GAEK,EAGL,GAAA,CAAC,EAAO,SAAW,CAAA,CACrB,IAAM,EAAM,kCAEN,OADN,AAAA,MAAA,CAAA,EAAA,AAAA,MAAA,EAAA,KAAA,EAAA,EAAQ,KAAA,AAAA,GAAQ,EAAA,IAAA,CAAA,EAAA,2BAA2B,MAAA,CAAA,GAAO,CAAC,OAAA,EAAQ,gBAAA,EAAiB,OAAA,CAAM,GAC5E,AAAI,UAAU,EAAG,CAGzB,IAAM,EAAyF,CAC7F,QAAS,EAAC,CACV,QAAS,EAAC,AAAA,EAGN,GLtCN,EKyCE,SAHF,CAAA,EAGI,IFFiC,EACjC,EECA,EAAA,EAAA,UAAA,CAAY,EAAA,EAAA,cAAA,CAAgB,EAAA,EAAA,UAAA,CAAY,EAAA,EAAA,KAAxC,CAGG,GAAA,AAAA,CAAA,AAAkB,YAAlB,OAAO,EACJ,EAAO,CAAC,WAAA,EAAY,WAAA,EAAY,cAAA,EAAe,eAAA,EAAgB,MAAA,CAAA,GAC/D,EAAc,CAAC,WAAA,EAAY,WAAA,EAAY,cAAA,EAAe,eAAA,EAAgB,MAAA,CAAA,EAAA,IAAa,CAAA,EAWhF,OATH,GACF,EAAO,OAAA,CAAQ,IAAK,CAAA,CAClB,KA6EHiM,EAAmB,EA7EW,IAC3B,MAAO,GAAG,MAAA,CAAA,EAAM,KAAM,CAAA,EArDV,KAsDV,MAAA,CAAA,EAAM,MAAS,CAtDL,GAsDuB,MAAQ,IAE3C,OAAQ,EAAM,MAAA,AAAA,GAGX,EAGL,GACF,EAAO,OAAA,CAAQ,IAAK,CAAA,CAClB,KAiEDA,EAAmB,EAjES,IAC3B,MAAO,GAAG,MAAA,CAAA,EAAM,KAAM,CAAA,EAjER,KAiE8B,MAAA,CAAA,EAAM,MAAS,CAjE7C,GAiE+D,MAAQ,IACrF,OAAQ,EAAM,MAAA,AAAA,GAIlB,IAAmC,EFxBnC,CAHY,OADZ,EAAyB,AAAqB,UAArB,OADQ,EE8B/B,AAA4B,YAA5B,OAAO,EAAO,SAAc,CACxB,EAAO,SAAU,CAAA,GACjB,EAAO,SAAA,EF/B4C,EAAY,EAAU,OAAA,GAEvE,CAAA,EAAA,EAAQ,OAAQ,CAAA,MAAO,GADnC,EAGI,AAAqB,UAArB,OAAO,GACF,CAAC,QAAA,CAAO,EAEV,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,CAAA,EAAI,GAAJ,CAAe,QAAA,C,GEqBX,EAA4B,EAA5B,OAAA,CAAS,EAAmB,EAAnB,SAAA,CAAW,EAAQ,EAAR,IAA3B,CAKA,GAAI,CAAC,EAAgB,OAAA,EACrB,IAAY,EAAmB,EAAxB,GAAA,CAAgB,EAAQ,EAAf,KAAhB,CAEO,MAAAD,AAAAA,CAAAA,EAAAA,EAAAA,CAAAA,AAAAA,EACL,EACA,CACE,OAAQ,YACR,KAAM,AHtFT,SAAuB,CAAmE,EACzF,IACJ,EAME,EANF,OAAA,CACW,EAKT,EALF,SAAA,CAAW,EAAA,AAAA,KAAA,IAAA,EAAa,UAAb,EACL,EAIJ,EAJF,IAAA,CAAM,EAAA,AAAA,KAAA,IAAA,EAAQ,UAAR,EACN,EAGE,EAHF,EAAA,CACA,EAEE,EAFF,IAAA,CACA,EACE,EADF,IANI,CASN,GAAI,CAAC,EACG,MAAA,AAAI,MAAM,uBAElB,GAAI,CAAC,EACG,MAAA,AAAI,MAAM,oBAElB,GAAI,CAAC,EACG,MAAA,AAAI,MAAM,kBAElB,GAAI,AAAY,MAAZ,GAAmB,EAAQ,QAAA,CAAS,KAChC,MAAA,AAAI,MAAM,qCAGZ,IAAA,EAAY,AAAe,YAAf,EAA2B,KAAY,EAAA,EACnD,EAAO,AAAU,YAAV,EAAsB,KAAY,EAAA,EAGzC,ED7BF,AAAA,AC6BsB,ED7BnB,UAAW,CAAA,GACT,AC4BiB,ED5Bd,KAAM,CAAA,EAAc,MAAM,EC4BZ,EACpB,EAAkB,MAAM,OAAA,CAAQ,GAClCD,EAAoB,EAAqB,IACzC,EAIE,EAAe,IAAI,gBAAgB,CACvC,QAAA,EACA,GAAA,EACA,KAAA,EACA,KAAM,CAAA,GAEJ,GACW,EAAA,GAAA,CAAI,YAAa,GAE5B,GACW,EAAA,GAAA,CAAI,OAAQ,GAG3B,IAAM,EAAW,CAAC,AAAY,MAAZ,EAAkB,GAAK,EAAO,CAC5C,GACF,EAAS,IAAA,CAAK,GAEhB,IAAM,EAAe,CACnB,oBACA,MAAM,MAAA,CAAA,GACN,QAAQ,MAAA,CAAA,GACR,QAAQ,MAAA,CAAA,mBAAmB,IAC7B,CAKO,OAJH,GACW,EAAA,IAAA,CAAK,QAAQ,MAAM,CAAA,IAEzB,EAAA,IAAA,CAAK,SAAU,OAAQ,GAAG,MAAA,CAAA,EAAa,IAAK,CAAA,KAAI,KAAI,MAAc,CAAA,IACpE,EAAS,IAAA,CAAK,IACvB,EGwB8B,CAClB,QAAA,EACA,UAAA,EACA,KAAA,EACA,GAAA,EACA,KAAA,EACA,KAAM,CAAA,EACP,EAGH,CAAA,EACF,ELzFG,ADNF,SAAS,EACd,CAAA,CACA,CACA,EAAA,IAAA,EAAA,UAAA,MAAA,CAAA,GAAA,AAAA,KAAA,IAAA,SAAA,CAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAmC,EAC1B,QACL,AFXG,AAAU,OEWL,GFXa,MAAM,OAAA,CEWnB,GACH,EAAM,GAAA,CAAI,SAAC,CAAA,CAAG,CADnB,EAEI,GAAA,EAAS,GAAI,CACT,IAAA,EAAO,EAAE,IAAM,CACjB,GAAA,AAAgB,UAAhB,OAAO,EACF,OAAA,EAAQ,EAAG,EAAW,EAAK,MAAA,CAAO,CAAC,KAAA,EAAM,OAAQ,CAAG,GAC7D,CAGF,OAAO,EAAQ,EAAG,EAAW,EAAK,MAAA,CAAO,GAAI,GAI7C,EAAS,GACJ,OAAO,WAAA,CACZ,OAAO,OAAA,CAAQ,GAAO,GAAA,CAAI,SAF1B,CAAA,EAE4B,IAAA,EAAA,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,EAAA,GAAA,EAAA,CAAA,CAAA,EAAA,CAAU,MAAA,CAAC,EAAG,EAAd,CAAA,CAAA,EAAA,CAAyB,EAAW,EAAK,MAAA,CAAO,IAAI,A,IAI7E,EAAU,EAAO,EAC1B,EMkBI,ELrCqB,SAAC,CAAA,CAAO,CAA/B,EAEM,GAAA,AAAiB,UAAjB,OAAO,EACF,OAAA,EAGH,IAAA,EAAuB,AJdjB,SACd,CAAA,CACA,CAOY,EACR,GAAC,AAAA,MAAA,EAAA,KAAA,EAAA,EAAK,QAAU,EAGpB,IDUuB,ECVjB,GDUiB,EAoIhB,AC9IkD,ED8I7C,GAAI,CAAA,SAAC,CAAV,EACD,GAAmB,UAAnB,OAAO,GAIP,AAAmB,UAAnB,OAAO,EAHF,OAAA,EAOL,GAAA,AAAmB,KAAnB,EAAQ,MAAA,CACV,OAAO,EAAQ,MAAA,AAGjB,OAAM,AAAI,MAAM,mBAAmB,MAAK,CAAA,KAAA,SAAA,CAAU,IAAU,GAhJvD,IAAI,MAAA,CAAA,EACR,GAAI,CAAA,SAAC,CADR,EAEQ,GAAA,AAAmB,UAAnB,OAAO,EAAsB,CAC/B,IAAM,EAAa,EAAQ,OAAQ,CAAA,iBAAkB,SAAC,CAAtD,EACE,OAAO,CAAA,CAAO,EAAK,AAAA,GAErB,MAAO,KAAK,MAAU,CAAA,EAAA,KAAA,CAGpB,GAAA,AAAmB,UAAnB,OAAO,EACT,MAAO,IAAI,MAAO,CAAA,EAAA,KAGhB,GAAA,AAAiB,KAAjB,EAAQ,IAAA,CAAa,CACvB,IAAM,EAAa,EAAQ,IAAA,CAAK,OAAQ,CAAA,SAAU,SAAC,CAAnD,EACE,OAAO,CAAA,CAAO,EAAK,AAAA,GAErB,MAAO,eAAe,MAAU,CAAA,EAAA,MAAA,CAG3B,MAAA,IAAI,MAAA,CAAA,EAAQ,MAAM,CAAA,IAAA,GAE1B,IAAA,CAAK,MC/BR,GAAI,AAAoC,KAAW,IAA/C,EAAI,QAAA,CAAS,EAAiB,CACzB,MAAA,CACL,QAAS,EAAI,QAAA,CAAS,EAAiB,CACvC,YAAa,EACb,WAAY,EAAA,EAIV,IAAA,EAAW,OAAO,OAAA,CAAQ,EAAI,QAAQ,EACzC,MAAA,CAAO,SADJ,CAAA,EACM,IAAA,EAAA,AAAA,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,EAAA,EAAA,CAAA,EAAA,CAAS,OAAA,EAAkB,UAAA,CAAW,EAC/C,GAAA,IAAA,CAAK,SAAL,CAAA,CAAA,CAAA,EAAO,IAAA,EAAA,AAAA,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,EAAA,EAAA,CAAA,EAAA,CAAkB,MAAA,AAAlB,AAAA,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,EAAA,EAAA,CAAA,EAAA,CAAuB,MAAS,CAAA,EAAK,MAAM,A,GAEjD,GAAA,AAAmB,GAAnB,EAAS,MAAA,EAIb,IAA+B,EAAA,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,CAAA,CAAS,EAAC,CAAA,GAAlC,EAAwB,CAAA,CAAA,EAAA,CAAX,EAAW,CAA/B,CAAA,EAAA,CACM,EAAa,EAAkB,SAAU,CAAA,EAAY,MAAM,EAC1D,MAAA,CAAC,QAAA,EAAS,YAAA,EAAa,WAAA,CAAU,GAC1C,EIpBgD,EKgC5C,GL/BA,GAAI,CAAC,EACI,OAAA,EAGH,IAAC,EAAwB,EAAxB,OAAA,CAAS,EAAe,EAAf,WAAV,CACF,GAAiB,UAAjB,EAAQ,IAAA,EAIR,AAAwB,kBAAxB,EAAQ,MAAO,CAAA,IAAA,CAHV,OAAA,EAOT,IAAM,EAAiB,AKkBvB,ELlB2B,SAAU,CAAA,EAAQ,MAAA,CAAO,QAAS,CAAA,CACvD,EAAa,AKiBnB,ELjBuB,KAAM,CAAA,EAAQ,MAAA,CAAO,IAAI,CAAA,CAE1C,EAAoB,EAAc,GAIxC,OAAO,EAAQ,CACb,WAHyB,AADA,EAAc,GACK,MAAA,CAAO,EAAK,KAAM,CAAA,EAAkB,MAAM,GAItF,eAAA,EACA,WAAY,EACZ,MAAA,CAAA,EACD,IK6DH,GAAI,EAAQ,CACJ,IAAA,EAAa,EAAO,OAAQ,CAAA,MAAA,CAC5B,EAAa,EAAO,OAAQ,CAAA,MAAA,CAa9B,GAZA,CAAA,GAAc,CAAA,IACd,AAAA,MAAA,CAAA,EAAA,AAAA,CAAA,AAAA,MAAA,EAAA,KAAA,EAAA,EAAQ,cAAA,AAAA,GAAkB,EAAO,GAAjC,AAAiC,GAAjC,EACA,2DAEF,AAAA,MAAA,CAAA,EAAA,EAAO,GAAA,AAAA,GAAP,EAAA,IAAA,CAAA,EACE,0CAA0C,MAAO,CAAA,EAAA,OAAA,CAAQ,MAAM,CAAA,eAAc,MAAA,CAAA,EAAO,OAAQ,CAAA,MAAA,IAG5F,EAAO,OAAQ,CAAA,MAAA,CAAS,IAC1B,AAAA,MAAA,CAAA,EAAA,AAAA,MAAA,EAAA,KAAA,EAAA,EAAQ,GAAA,AAAA,GAAM,EAAA,IAAA,CAAA,EAAA,kDACZ,AAAA,MAAA,CAAA,EAAQ,AAAA,CAAA,AAAA,MAAA,EAAA,KAAA,EAAA,EAAA,KAAA,AAAA,GAAS,EAAO,GAAA,AAAA,GAAxB,EAA+B,EAAO,OAAA,GAEtC,EAAO,OAAQ,CAAA,MAAA,CAAS,EAAG,CACvB,IAAA,EAAA,IAAc,IACpB,EAAA,CAAA,EAAA,EAAA,CAAA,EAAA,EAAA,KAAA,E,G,CAAA,IAAA,ILhHJ,EKZF,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EA4HM,EAAA,EAAqB,EAAO,OAAS,CAAA,OAAA,QAAA,CAAA,GAArC,CAAA,CAAA,EAAA,AAAA,CAAA,EAAA,EAAA,IAAA,EAAA,EAAA,IAAA,AAAA,EAAA,EAAA,CAAA,EAAA,CAAA,IAAY,EAAZ,EAAA,KAAA,CAAY,IAAZ,CACU,EAAA,GAAA,CAAI,EAAK,OAAQ,CAAA,EAAc,KAAK,OAAA,CAAQ,WAAY,M,C,C,M,E,CADlE,EAAA,CAAA,EAAA,EAAA,C,Q,C,G,CAAA,GAAA,AAAA,MAAA,EAAA,MAAA,EAAA,EAAA,MAAA,E,Q,CAAA,GAAA,EAAA,MAAA,C,C,CAGA,AAAA,MAAA,CAAA,EAAA,AAAA,MAAA,EAAA,KAAA,EAAA,EAAQ,GAAA,AAAA,GAAM,EAAA,IAAA,CAAA,EAAA,gDAAkD,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAG,EAAQ,MAAA,IAAQ,CAGjF,CAAA,GAAc,CAAA,GAChB,CAAA,AAAA,MAAA,CAAA,EAAA,AAAA,MAAA,EAAA,KAAA,EAAA,EAAQ,QAAR,AAAQ,GAAR,EAAA,IAAA,CAAA,EADF,CAEA,CAGK,OAAA,CACT,C,E","sources":["<anon>","node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap-gZIRaYar.js","node_modules/@sanity/client/src/csm/studioPath.ts","node_modules/@sanity/client/src/csm/jsonPath.ts","node_modules/@sanity/client/src/csm/resolveMapping.ts","node_modules/@sanity/client/src/csm/isArray.ts","node_modules/@sanity/client/src/csm/isRecord.ts","node_modules/@sanity/client/src/csm/walkMap.ts","node_modules/@sanity/client/src/stega/encodeIntoResult.ts","node_modules/@sanity/client/src/csm/getPublishedId.ts","node_modules/@sanity/client/src/csm/createEditUrl.ts","node_modules/@sanity/client/src/csm/resolveEditInfo.ts","node_modules/@sanity/client/src/stega/filterDefault.ts","node_modules/@sanity/client/src/stega/stegaEncodeSourceMap.ts"],"sourcesContent":["(function () {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire1d06\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"h1mIU\", function(module, exports) {\n\n$parcel$export(module.exports, \"stegaEncodeSourceMap$1\", function () { return $c64428117a1f496a$export$2b977f49f39a7e5e; });\n\nvar $do9pw = parcelRequire(\"do9pw\");\n\nvar $cxjpp = parcelRequire(\"cxjpp\");\n\nvar $cv9Rk = parcelRequire(\"cv9Rk\");\n\nvar $c6Xmf = parcelRequire(\"c6Xmf\");\n\nvar $l0HdX = parcelRequire(\"l0HdX\");\n\nvar $lipNE = parcelRequire(\"lipNE\");\nvar $c64428117a1f496a$var$reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction $c64428117a1f496a$var$isKeySegment(segment) {\n    if (typeof segment === \"string\") return $c64428117a1f496a$var$reKeySegment.test(segment.trim());\n    return typeof segment === \"object\" && \"_key\" in segment;\n}\nfunction $c64428117a1f496a$var$toString(path) {\n    if (!Array.isArray(path)) throw new Error(\"Path is not an array\");\n    return path.reduce(function(target, segment, i) {\n        var segmentType = typeof segment === \"undefined\" ? \"undefined\" : (0, $l0HdX._)(segment);\n        if (segmentType === \"number\") return \"\".concat(target, \"[\").concat(segment, \"]\");\n        if (segmentType === \"string\") {\n            var separator = i === 0 ? \"\" : \".\";\n            return \"\".concat(target).concat(separator).concat(segment);\n        }\n        if ($c64428117a1f496a$var$isKeySegment(segment) && segment._key) return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n        if (Array.isArray(segment)) {\n            var _segment = (0, $cv9Rk._)(segment, 2), from = _segment[0], to = _segment[1];\n            return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n        }\n        throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n    }, \"\");\n}\nvar $c64428117a1f496a$var$ESCAPE = {\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\",\n    \"'\": \"\\\\'\",\n    \"\\\\\": \"\\\\\\\\\"\n};\nvar $c64428117a1f496a$var$UNESCAPE = {\n    \"\\\\f\": \"\\f\",\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\t\",\n    \"\\\\'\": \"'\",\n    \"\\\\\\\\\": \"\\\\\"\n};\nfunction $c64428117a1f496a$var$jsonPath(path) {\n    return \"$\".concat(path.map(function(segment) {\n        if (typeof segment === \"string\") {\n            var escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, function(match) {\n                return $c64428117a1f496a$var$ESCAPE[match];\n            });\n            return \"['\".concat(escapedKey, \"']\");\n        }\n        if (typeof segment === \"number\") return \"[\".concat(segment, \"]\");\n        if (segment._key !== \"\") {\n            var escapedKey1 = segment._key.replace(/['\\\\]/g, function(match) {\n                return $c64428117a1f496a$var$ESCAPE[match];\n            });\n            return \"[?(@._key=='\".concat(escapedKey1, \"')]\");\n        }\n        return \"[\".concat(segment._index, \"]\");\n    }).join(\"\"));\n}\nfunction $c64428117a1f496a$var$parseJsonPath(path) {\n    var parsed = [];\n    var parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n    var match;\n    while((match = parseRe.exec(path)) !== null){\n        if (match[1] !== void 0) {\n            var key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, function(m) {\n                return $c64428117a1f496a$var$UNESCAPE[m];\n            });\n            parsed.push(key);\n            continue;\n        }\n        if (match[2] !== void 0) {\n            parsed.push(parseInt(match[2], 10));\n            continue;\n        }\n        if (match[3] !== void 0) {\n            var _key = match[3].replace(/\\\\(\\\\')/g, function(m) {\n                return $c64428117a1f496a$var$UNESCAPE[m];\n            });\n            parsed.push({\n                _key: _key,\n                _index: -1\n            });\n            continue;\n        }\n    }\n    return parsed;\n}\nfunction $c64428117a1f496a$var$jsonPathToStudioPath(path) {\n    return path.map(function(segment) {\n        if (typeof segment === \"string\") return segment;\n        if (typeof segment === \"number\") return segment;\n        if (segment._key !== \"\") return {\n            _key: segment._key\n        };\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction $c64428117a1f496a$var$jsonPathToMappingPath(path) {\n    return path.map(function(segment) {\n        if (typeof segment === \"string\") return segment;\n        if (typeof segment === \"number\") return segment;\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction $c64428117a1f496a$var$resolveMapping(resultPath, csm) {\n    if (!(csm == null ? void 0 : csm.mappings)) return void 0;\n    var resultMappingPath = $c64428117a1f496a$var$jsonPath($c64428117a1f496a$var$jsonPathToMappingPath(resultPath));\n    if (csm.mappings[resultMappingPath] !== void 0) return {\n        mapping: csm.mappings[resultMappingPath],\n        matchedPath: resultMappingPath,\n        pathSuffix: \"\"\n    };\n    var mappings = Object.entries(csm.mappings).filter(function(param) {\n        var _param = (0, $cv9Rk._)(param, 1), key = _param[0];\n        return resultMappingPath.startsWith(key);\n    }).sort(function(param, param1) {\n        var _param = (0, $cv9Rk._)(param, 1), key1 = _param[0], _param1 = (0, $cv9Rk._)(param1, 1), key2 = _param1[0];\n        return key2.length - key1.length;\n    });\n    if (mappings.length == 0) return void 0;\n    var _mappings_ = (0, $cv9Rk._)(mappings[0], 2), matchedPath = _mappings_[0], mapping = _mappings_[1];\n    var pathSuffix = resultMappingPath.substring(matchedPath.length);\n    return {\n        mapping: mapping,\n        matchedPath: matchedPath,\n        pathSuffix: pathSuffix\n    };\n}\nfunction $c64428117a1f496a$var$isArray(value) {\n    return value !== null && Array.isArray(value);\n}\nfunction $c64428117a1f496a$var$isRecord(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction $c64428117a1f496a$var$walkMap(value, mappingFn) {\n    var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    if ($c64428117a1f496a$var$isArray(value)) return value.map(function(v, idx) {\n        if ($c64428117a1f496a$var$isRecord(v)) {\n            var _key = v[\"_key\"];\n            if (typeof _key === \"string\") return $c64428117a1f496a$var$walkMap(v, mappingFn, path.concat({\n                _key: _key,\n                _index: idx\n            }));\n        }\n        return $c64428117a1f496a$var$walkMap(v, mappingFn, path.concat(idx));\n    });\n    if ($c64428117a1f496a$var$isRecord(value)) return Object.fromEntries(Object.entries(value).map(function(param) {\n        var _param = (0, $cv9Rk._)(param, 2), k = _param[0], v = _param[1];\n        return [\n            k,\n            $c64428117a1f496a$var$walkMap(v, mappingFn, path.concat(k))\n        ];\n    }));\n    return mappingFn(value, path);\n}\nfunction $c64428117a1f496a$export$c57d17a25deaf8b7(result, csm, encoder) {\n    return $c64428117a1f496a$var$walkMap(result, function(value, path) {\n        if (typeof value !== \"string\") return value;\n        var resolveMappingResult = $c64428117a1f496a$var$resolveMapping(path, csm);\n        if (!resolveMappingResult) return value;\n        var mapping = resolveMappingResult.mapping, matchedPath = resolveMappingResult.matchedPath;\n        if (mapping.type !== \"value\") return value;\n        if (mapping.source.type !== \"documentValue\") return value;\n        var sourceDocument = csm.documents[mapping.source.document];\n        var sourcePath = csm.paths[mapping.source.path];\n        var matchPathSegments = $c64428117a1f496a$var$parseJsonPath(matchedPath);\n        var sourcePathSegments = $c64428117a1f496a$var$parseJsonPath(sourcePath);\n        var fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length));\n        return encoder({\n            sourcePath: fullSourceSegments,\n            sourceDocument: sourceDocument,\n            resultPath: path,\n            value: value\n        });\n    });\n}\nvar $c64428117a1f496a$var$DRAFTS_PREFIX = \"drafts.\";\nfunction $c64428117a1f496a$var$getPublishedId(id) {\n    if (id.startsWith($c64428117a1f496a$var$DRAFTS_PREFIX)) return id.slice($c64428117a1f496a$var$DRAFTS_PREFIX.length);\n    return id;\n}\nfunction $c64428117a1f496a$var$createEditUrl(options) {\n    var baseUrl = options.baseUrl, tmp = options.workspace, _workspace = tmp === void 0 ? \"default\" : tmp, tmp1 = options.tool, _tool = tmp1 === void 0 ? \"default\" : tmp1, _id = options.id, type = options.type, path = options.path;\n    if (!baseUrl) throw new Error(\"baseUrl is required\");\n    if (!path) throw new Error(\"path is required\");\n    if (!_id) throw new Error(\"id is required\");\n    if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) throw new Error(\"baseUrl must not end with a slash\");\n    var workspace = _workspace === \"default\" ? void 0 : _workspace;\n    var tool = _tool === \"default\" ? void 0 : _tool;\n    var id = $c64428117a1f496a$var$getPublishedId(_id);\n    var stringifiedPath = Array.isArray(path) ? $c64428117a1f496a$var$toString($c64428117a1f496a$var$jsonPathToStudioPath(path)) : path;\n    var searchParams = new URLSearchParams({\n        baseUrl: baseUrl,\n        id: id,\n        type: type,\n        path: stringifiedPath\n    });\n    if (workspace) searchParams.set(\"workspace\", workspace);\n    if (tool) searchParams.set(\"tool\", tool);\n    var segments = [\n        baseUrl === \"/\" ? \"\" : baseUrl\n    ];\n    if (workspace) segments.push(workspace);\n    var routerParams = [\n        \"mode=presentation\",\n        \"id=\".concat(id),\n        \"type=\".concat(type),\n        \"path=\".concat(encodeURIComponent(stringifiedPath))\n    ];\n    if (tool) routerParams.push(\"tool=\".concat(tool));\n    segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams));\n    return segments.join(\"/\");\n}\nfunction $c64428117a1f496a$var$resolveStudioBaseRoute(studioUrl) {\n    var baseUrl = typeof studioUrl === \"string\" ? studioUrl : studioUrl.baseUrl;\n    if (baseUrl !== \"/\") baseUrl = baseUrl.replace(/\\/$/, \"\");\n    if (typeof studioUrl === \"string\") return {\n        baseUrl: baseUrl\n    };\n    return (0, $cxjpp._)((0, $do9pw._)({}, studioUrl), {\n        baseUrl: baseUrl\n    });\n}\nvar $c64428117a1f496a$var$filterDefault = function(param) {\n    var sourcePath = param.sourcePath, value = param.value;\n    if ($c64428117a1f496a$var$isValidDate(value) || $c64428117a1f496a$var$isValidURL(value)) return false;\n    var endPath = sourcePath.at(-1);\n    if (sourcePath.at(-2) === \"slug\" && endPath === \"current\") return false;\n    if (typeof endPath === \"string\" && endPath.startsWith(\"_\")) return false;\n    if (typeof endPath === \"number\" && sourcePath.at(-2) === \"marks\") return false;\n    if (endPath === \"href\" && typeof sourcePath.at(-2) === \"number\" && sourcePath.at(-3) === \"markDefs\") return false;\n    if (endPath === \"style\" || endPath === \"listItem\") return false;\n    if (sourcePath.some(function(path) {\n        return path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\";\n    })) return false;\n    if (typeof endPath === \"string\" && $c64428117a1f496a$var$denylist.has(endPath)) return false;\n    return true;\n};\nvar $c64428117a1f496a$var$denylist = /* @__PURE__ */ new Set([\n    \"color\",\n    \"colour\",\n    \"currency\",\n    \"email\",\n    \"format\",\n    \"gid\",\n    \"hex\",\n    \"href\",\n    \"hsl\",\n    \"hsla\",\n    \"icon\",\n    \"id\",\n    \"index\",\n    \"key\",\n    \"language\",\n    \"layout\",\n    \"link\",\n    \"linkAction\",\n    \"locale\",\n    \"lqip\",\n    \"page\",\n    \"path\",\n    \"ref\",\n    \"rgb\",\n    \"rgba\",\n    \"route\",\n    \"secret\",\n    \"slug\",\n    \"status\",\n    \"tag\",\n    \"template\",\n    \"theme\",\n    \"type\",\n    \"unit\",\n    \"url\",\n    \"username\",\n    \"variant\",\n    \"website\"\n]);\nfunction $c64428117a1f496a$var$isValidDate(dateString) {\n    return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false;\n}\nfunction $c64428117a1f496a$var$isValidURL(url) {\n    try {\n        new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\nvar $c64428117a1f496a$var$TRUNCATE_LENGTH = 20;\nfunction $c64428117a1f496a$export$ae58eb1491425156(result, resultSourceMap, config) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    var filter = config.filter, logger = config.logger, enabled = config.enabled;\n    if (!enabled) {\n        var msg = \"config.enabled must be true, don't call this function otherwise\";\n        (_a = logger == null ? void 0 : logger.error) == null || _a.call(logger, \"[@sanity/client/stega]: \".concat(msg), {\n            result: result,\n            resultSourceMap: resultSourceMap,\n            config: config\n        });\n        throw new TypeError(msg);\n    }\n    if (!resultSourceMap) {\n        (_b = logger == null ? void 0 : logger.error) == null || _b.call(logger, \"[@sanity/client/stega]: Missing Content Source Map from response body\", {\n            result: result,\n            resultSourceMap: resultSourceMap,\n            config: config\n        });\n        return result;\n    }\n    if (!config.studioUrl) {\n        var msg1 = \"config.studioUrl must be defined\";\n        (_c = logger == null ? void 0 : logger.error) == null || _c.call(logger, \"[@sanity/client/stega]: \".concat(msg1), {\n            result: result,\n            resultSourceMap: resultSourceMap,\n            config: config\n        });\n        throw new TypeError(msg1);\n    }\n    var report = {\n        encoded: [],\n        skipped: []\n    };\n    var resultWithStega = $c64428117a1f496a$export$c57d17a25deaf8b7(result, resultSourceMap, function(param) {\n        var sourcePath = param.sourcePath, sourceDocument = param.sourceDocument, resultPath = param.resultPath, value = param.value;\n        if ((typeof filter === \"function\" ? filter({\n            sourcePath: sourcePath,\n            resultPath: resultPath,\n            filterDefault: $c64428117a1f496a$var$filterDefault,\n            sourceDocument: sourceDocument,\n            value: value\n        }) : $c64428117a1f496a$var$filterDefault({\n            sourcePath: sourcePath,\n            resultPath: resultPath,\n            filterDefault: $c64428117a1f496a$var$filterDefault,\n            sourceDocument: sourceDocument,\n            value: value\n        })) === false) {\n            if (logger) report.skipped.push({\n                path: $c64428117a1f496a$var$prettyPathForLogging(sourcePath),\n                value: \"\".concat(value.slice(0, $c64428117a1f496a$var$TRUNCATE_LENGTH)).concat(value.length > $c64428117a1f496a$var$TRUNCATE_LENGTH ? \"...\" : \"\"),\n                length: value.length\n            });\n            return value;\n        }\n        if (logger) report.encoded.push({\n            path: $c64428117a1f496a$var$prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, $c64428117a1f496a$var$TRUNCATE_LENGTH)).concat(value.length > $c64428117a1f496a$var$TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n        });\n        var _resolveStudioBaseRoute = $c64428117a1f496a$var$resolveStudioBaseRoute(typeof config.studioUrl === \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl), baseUrl = _resolveStudioBaseRoute.baseUrl, workspace = _resolveStudioBaseRoute.workspace, tool = _resolveStudioBaseRoute.tool;\n        if (!baseUrl) return value;\n        var id = sourceDocument._id, type = sourceDocument._type;\n        return (0, $lipNE.b)(value, {\n            origin: \"sanity.io\",\n            href: $c64428117a1f496a$var$createEditUrl({\n                baseUrl: baseUrl,\n                workspace: workspace,\n                tool: tool,\n                id: id,\n                type: type,\n                path: sourcePath\n            })\n        }, // We use custom logic to determine if we should skip encoding\n        false);\n    });\n    if (logger) {\n        var isSkipping = report.skipped.length;\n        var isEncoding = report.encoded.length;\n        if (isSkipping || isEncoding) {\n            (_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null || _d(\"[@sanity/client/stega]: Encoding source map into result\");\n            (_e = logger.log) == null || _e.call(logger, \"[@sanity/client/stega]: Paths encoded: \".concat(report.encoded.length, \", skipped: \").concat(report.skipped.length));\n        }\n        if (report.encoded.length > 0) {\n            (_f = logger == null ? void 0 : logger.log) == null || _f.call(logger, \"[@sanity/client/stega]: Table of encoded paths\");\n            (_g = (logger == null ? void 0 : logger.table) || logger.log) == null || _g(report.encoded);\n        }\n        if (report.skipped.length > 0) {\n            var skipped = /* @__PURE__ */ new Set();\n            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            try {\n                for(var _iterator = report.skipped[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                    var path = _step.value.path;\n                    skipped.add(path.replace($c64428117a1f496a$var$reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                    }\n                } finally{\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n            (_h = logger == null ? void 0 : logger.log) == null || _h.call(logger, \"[@sanity/client/stega]: List of skipped paths\", (0, $c6Xmf._)(skipped.values()));\n        }\n        if (isSkipping || isEncoding) (_i = logger == null ? void 0 : logger.groupEnd) == null || _i.call(logger);\n    }\n    return resultWithStega;\n}\nfunction $c64428117a1f496a$var$prettyPathForLogging(path) {\n    return $c64428117a1f496a$var$toString($c64428117a1f496a$var$jsonPathToStudioPath(path));\n}\nvar $c64428117a1f496a$export$2b977f49f39a7e5e = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    stegaEncodeSourceMap: $c64428117a1f496a$export$ae58eb1491425156\n});\n\n});\n\n})();\n//# sourceMappingURL=stegaEncodeSourceMap-gZIRaYar.bbddeca9.js.map\n","import { b } from './browserMiddleware-zDVeirri.js';\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  if (typeof segment === \"string\") {\n    return reKeySegment.test(segment.trim());\n  }\n  return typeof segment === \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path)) {\n    throw new Error(\"Path is not an array\");\n  }\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\") {\n      return \"\".concat(target, \"[\").concat(segment, \"]\");\n    }\n    if (segmentType === \"string\") {\n      const separator = i === 0 ? \"\" : \".\";\n      return \"\".concat(target).concat(separator).concat(segment);\n    }\n    if (isKeySegment(segment) && segment._key) {\n      return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n    }\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n    }\n    throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n  }, \"\");\n}\n\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n};\nconst UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": \"\\n\",\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return \"$\".concat(path.map((segment) => {\n    if (typeof segment === \"string\") {\n      const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n        return ESCAPE[match];\n      });\n      return \"['\".concat(escapedKey, \"']\");\n    }\n    if (typeof segment === \"number\") {\n      return \"[\".concat(segment, \"]\");\n    }\n    if (segment._key !== \"\") {\n      const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n        return ESCAPE[match];\n      });\n      return \"[?(@._key=='\".concat(escapedKey, \"')]\");\n    }\n    return \"[\".concat(segment._index, \"]\");\n  }).join(\"\"));\n}\nfunction parseJsonPath(path) {\n  const parsed = [];\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m];\n      });\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m];\n      });\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (segment._key !== \"\") {\n      return { _key: segment._key };\n    }\n    if (segment._index !== -1) {\n      return segment._index;\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (segment._index !== -1) {\n      return segment._index;\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\n\nfunction resolveMapping(resultPath, csm) {\n  if (!(csm == null ? void 0 : csm.mappings)) {\n    return void 0;\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  }\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0) {\n    return void 0;\n  }\n  const [matchedPath, mapping] = mappings[0];\n  const pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\n\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\n\nfunction isRecord(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v[\"_key\"];\n        if (typeof _key === \"string\") {\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n        }\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  }\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\n\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult) {\n      return value;\n    }\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\") {\n      return value;\n    }\n    if (mapping.source.type !== \"documentValue\") {\n      return value;\n    }\n    const sourceDocument = csm.documents[mapping.source.document];\n    const sourcePath = csm.paths[mapping.source.path];\n    const matchPathSegments = parseJsonPath(matchedPath);\n    const sourcePathSegments = parseJsonPath(sourcePath);\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\n\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length);\n  }\n  return id;\n}\n\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path\n  } = options;\n  if (!baseUrl) {\n    throw new Error(\"baseUrl is required\");\n  }\n  if (!path) {\n    throw new Error(\"path is required\");\n  }\n  if (!_id) {\n    throw new Error(\"id is required\");\n  }\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) {\n    throw new Error(\"baseUrl must not end with a slash\");\n  }\n  const workspace = _workspace === \"default\" ? void 0 : _workspace;\n  const tool = _tool === \"default\" ? void 0 : _tool;\n  const id = getPublishedId(_id);\n  const stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path;\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  if (workspace) {\n    searchParams.set(\"workspace\", workspace);\n  }\n  if (tool) {\n    searchParams.set(\"tool\", tool);\n  }\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  if (workspace) {\n    segments.push(workspace);\n  }\n  const routerParams = [\n    \"mode=presentation\",\n    \"id=\".concat(id),\n    \"type=\".concat(type),\n    \"path=\".concat(encodeURIComponent(stringifiedPath))\n  ];\n  if (tool) {\n    routerParams.push(\"tool=\".concat(tool));\n  }\n  segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams));\n  return segments.join(\"/\");\n}\n\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl === \"string\" ? studioUrl : studioUrl.baseUrl;\n  if (baseUrl !== \"/\") {\n    baseUrl = baseUrl.replace(/\\/$/, \"\");\n  }\n  if (typeof studioUrl === \"string\") {\n    return { baseUrl };\n  }\n  return { ...studioUrl, baseUrl };\n}\n\nconst filterDefault = ({ sourcePath, value }) => {\n  if (isValidDate(value) || isValidURL(value)) {\n    return false;\n  }\n  const endPath = sourcePath.at(-1);\n  if (sourcePath.at(-2) === \"slug\" && endPath === \"current\") {\n    return false;\n  }\n  if (typeof endPath === \"string\" && endPath.startsWith(\"_\")) {\n    return false;\n  }\n  if (typeof endPath === \"number\" && sourcePath.at(-2) === \"marks\") {\n    return false;\n  }\n  if (endPath === \"href\" && typeof sourcePath.at(-2) === \"number\" && sourcePath.at(-3) === \"markDefs\") {\n    return false;\n  }\n  if (endPath === \"style\" || endPath === \"listItem\") {\n    return false;\n  }\n  if (sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  )) {\n    return false;\n  }\n  if (typeof endPath === \"string\" && denylist.has(endPath)) {\n    return false;\n  }\n  return true;\n};\nconst denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return false;\n  }\n  return true;\n}\n\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, \"[@sanity/client/stega]: \".concat(msg), { result, resultSourceMap, config });\n    throw new TypeError(msg);\n  }\n  if (!resultSourceMap) {\n    (_b = logger == null ? void 0 : logger.error) == null ? void 0 : _b.call(logger, \"[@sanity/client/stega]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    });\n    return result;\n  }\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    (_c = logger == null ? void 0 : logger.error) == null ? void 0 : _c.call(logger, \"[@sanity/client/stega]: \".concat(msg), { result, resultSourceMap, config });\n    throw new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  };\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter === \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === false) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n          });\n        }\n        return value;\n      }\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n          length: value.length\n        });\n      }\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl === \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl)\n        return value;\n      const { _id: id, _type: type } = sourceDocument;\n      return b(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        false\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length;\n    const isEncoding = report.encoded.length;\n    if (isSkipping || isEncoding) {\n      (_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null ? void 0 : _d(\n        \"[@sanity/client/stega]: Encoding source map into result\"\n      );\n      (_e = logger.log) == null ? void 0 : _e.call(\n        logger,\n        \"[@sanity/client/stega]: Paths encoded: \".concat(report.encoded.length, \", skipped: \").concat(report.skipped.length)\n      );\n    }\n    if (report.encoded.length > 0) {\n      (_f = logger == null ? void 0 : logger.log) == null ? void 0 : _f.call(logger, \"[@sanity/client/stega]: Table of encoded paths\");\n      (_g = (logger == null ? void 0 : logger.table) || logger.log) == null ? void 0 : _g(report.encoded);\n    }\n    if (report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped) {\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      }\n      (_h = logger == null ? void 0 : logger.log) == null ? void 0 : _h.call(logger, \"[@sanity/client/stega]: List of skipped paths\", [...skipped.values()]);\n    }\n    if (isSkipping || isEncoding) {\n      (_i = logger == null ? void 0 : logger.groupEnd) == null ? void 0 : _i.call(logger);\n    }\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\n\nvar stegaEncodeSourceMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap: stegaEncodeSourceMap\n});\n\nexport { encodeIntoResult, stegaEncodeSourceMap, stegaEncodeSourceMap$1 };\n//# sourceMappingURL=stegaEncodeSourceMap-gZIRaYar.js.map\n","/** @alpha */\nexport type KeyedSegment = {_key: string}\n\n/** @alpha */\nexport type IndexTuple = [number | '', number | '']\n\n/** @alpha */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/** @alpha */\nexport type Path = PathSegment[]\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n/** @internal */\nexport const reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n\n/** @internal */\nexport function get<Result = unknown, Fallback = unknown>(\n  obj: unknown,\n  path: Path | string,\n  defaultVal?: Fallback,\n): Result | typeof defaultVal {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Result)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc as Result\n}\n\n/** @alpha */\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\n/** @alpha */\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(parsePathSegment)\n}\n\nfunction parsePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction parseIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction parseKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction parseIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n","import * as studioPath from './studioPath'\nimport type {\n  ContentSourceMapParsedPath,\n  ContentSourceMapParsedPathKeyedSegment,\n  ContentSourceMapPaths,\n  Path,\n} from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/**\n * @internal\n */\nexport function jsonPath(path: ContentSourceMapParsedPath): ContentSourceMapPaths[number] {\n  return `$${path\n    .map((segment) => {\n      if (typeof segment === 'string') {\n        const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      if (typeof segment === 'number') {\n        return `[${segment}]`\n      }\n\n      if (segment._key !== '') {\n        const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `[?(@._key=='${escapedKey}')]`\n      }\n\n      return `[${segment._index}]`\n    })\n    .join('')}`\n}\n\n/**\n * @internal\n */\nexport function parseJsonPath(path: ContentSourceMapPaths[number]): ContentSourceMapParsedPath {\n  const parsed: ContentSourceMapParsedPath = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n\n    if (match[3] !== undefined) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push({\n        _key,\n        _index: -1,\n      })\n      continue\n    }\n  }\n\n  return parsed\n}\n\n/**\n * @internal\n */\nexport function jsonPathToStudioPath(path: ContentSourceMapParsedPath): Path {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._key !== '') {\n      return {_key: segment._key}\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\n/**\n * @internal\n */\nexport function studioPathToJsonPath(path: Path | string): ContentSourceMapParsedPath {\n  const parsedPath = typeof path === 'string' ? studioPath.fromString(path) : path\n\n  return parsedPath.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (Array.isArray(segment)) {\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`)\n    }\n\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment\n    }\n\n    if (segment._key) {\n      return {_key: segment._key, _index: -1}\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\nfunction isContentSourceMapParsedPathKeyedSegment(\n  segment: studioPath.PathSegment | ContentSourceMapParsedPath[number],\n): segment is ContentSourceMapParsedPathKeyedSegment {\n  return typeof segment === 'object' && '_key' in segment && '_index' in segment\n}\n\n/**\n * @internal\n */\nexport function jsonPathToMappingPath(path: ContentSourceMapParsedPath): (string | number)[] {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n","import {jsonPath, jsonPathToMappingPath} from './jsonPath'\nimport type {ContentSourceMap, ContentSourceMapMapping, ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolveMapping(\n  resultPath: ContentSourceMapParsedPath,\n  csm?: ContentSourceMap,\n):\n  | {\n      mapping: ContentSourceMapMapping\n      matchedPath: string\n      pathSuffix: string\n    }\n  | undefined {\n  if (!csm?.mappings) {\n    return undefined\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath))\n\n  if (csm.mappings[resultMappingPath] !== undefined) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: '',\n    }\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultMappingPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultMappingPath.substring(matchedPath.length)\n  return {mapping, matchedPath, pathSuffix}\n}\n","/** @internal */\nexport function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n","/** @internal */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n","import {isArray} from './isArray'\nimport {isRecord} from './isRecord'\nimport type {ContentSourceMapParsedPath, WalkMapFn} from './types'\n\n/**\n * generic way to walk a nested object or array and apply a mapping function to each value\n * @internal\n */\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: ContentSourceMapParsedPath = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v['_key']\n        if (typeof _key === 'string') {\n          return walkMap(v, mappingFn, path.concat({_key, _index: idx}))\n        }\n      }\n\n      return walkMap(v, mappingFn, path.concat(idx))\n    })\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n","import {parseJsonPath} from '../csm/jsonPath'\nimport {resolveMapping} from '../csm/resolveMapping'\nimport type {ContentSourceMap} from '../csm/types'\nimport {walkMap} from '../csm/walkMap'\nimport type {Encoder} from './types'\n\n/**\n * @internal\n */\nexport function encodeIntoResult<Result>(\n  result: Result,\n  csm: ContentSourceMap,\n  encoder: Encoder,\n): Result {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const {mapping, matchedPath} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = csm.documents[mapping.source.document!]\n    const sourcePath = csm.paths[mapping.source.path]\n\n    const matchPathSegments = parseJsonPath(matchedPath)\n    const sourcePathSegments = parseJsonPath(sourcePath)\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length))\n\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value,\n    })\n  }) as Result\n}\n","export const DRAFTS_PREFIX = 'drafts.'\n\n/** @internal */\nexport function getPublishedId(id: string): string {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length)\n  }\n\n  return id\n}\n","import {getPublishedId} from './getPublishedId'\nimport {jsonPathToStudioPath} from './jsonPath'\nimport * as studioPath from './studioPath'\nimport type {CreateEditUrlOptions, EditIntentUrl, StudioBaseUrl} from './types'\n\n/** @internal */\nexport function createEditUrl(options: CreateEditUrlOptions): `${StudioBaseUrl}${EditIntentUrl}` {\n  const {\n    baseUrl,\n    workspace: _workspace = 'default',\n    tool: _tool = 'default',\n    id: _id,\n    type,\n    path,\n  } = options\n\n  if (!baseUrl) {\n    throw new Error('baseUrl is required')\n  }\n  if (!path) {\n    throw new Error('path is required')\n  }\n  if (!_id) {\n    throw new Error('id is required')\n  }\n  if (baseUrl !== '/' && baseUrl.endsWith('/')) {\n    throw new Error('baseUrl must not end with a slash')\n  }\n\n  const workspace = _workspace === 'default' ? undefined : _workspace\n  const tool = _tool === 'default' ? undefined : _tool\n  // eslint-disable-next-line no-warning-comments\n  // @TODO allow passing draft prefixed IDs, to better open the right perspective mode\n  const id = getPublishedId(_id)\n  const stringifiedPath = Array.isArray(path)\n    ? studioPath.toString(jsonPathToStudioPath(path))\n    : path\n\n  // eslint-disable-next-line no-warning-comments\n  // @TODO Using searchParams as a temporary workaround until `@sanity/overlays` can decode state from the path reliably\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath,\n  })\n  if (workspace) {\n    searchParams.set('workspace', workspace)\n  }\n  if (tool) {\n    searchParams.set('tool', tool)\n  }\n\n  const segments = [baseUrl === '/' ? '' : baseUrl]\n  if (workspace) {\n    segments.push(workspace)\n  }\n  const routerParams = [\n    'mode=presentation',\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`,\n  ]\n  if (tool) {\n    routerParams.push(`tool=${tool}`)\n  }\n  segments.push('intent', 'edit', `${routerParams.join(';')}?${searchParams}`)\n  return segments.join('/') as unknown as `${StudioBaseUrl}${EditIntentUrl}`\n}\n","import {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport type {\n  CreateEditUrlOptions,\n  ResolveEditInfoOptions,\n  StudioBaseRoute,\n  StudioBaseUrl,\n  StudioUrl,\n} from './types'\n\n/** @internal */\nexport function resolveEditInfo(options: ResolveEditInfoOptions): CreateEditUrlOptions | undefined {\n  const {resultSourceMap: csm, resultPath} = options\n  const {mapping, pathSuffix} = resolveMapping(resultPath, csm) || {}\n\n  if (!mapping) {\n    // console.warn('no mapping for path', { path: resultPath, sourceMap: csm })\n    return undefined\n  }\n\n  if (mapping.source.type === 'literal') {\n    return undefined\n  }\n\n  if (mapping.source.type === 'unknown') {\n    return undefined\n  }\n\n  const sourceDoc = csm.documents[mapping.source.document]\n  const sourcePath = csm.paths[mapping.source.path]\n\n  if (sourceDoc && sourcePath) {\n    const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n      typeof options.studioUrl === 'function' ? options.studioUrl(sourceDoc) : options.studioUrl,\n    )\n    if (!baseUrl) return undefined\n    const {_id, _type} = sourceDoc\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n    } satisfies CreateEditUrlOptions\n  }\n\n  return undefined\n}\n\n/** @internal */\nexport function resolveStudioBaseRoute(studioUrl: StudioUrl): StudioBaseRoute {\n  let baseUrl: StudioBaseUrl = typeof studioUrl === 'string' ? studioUrl : studioUrl.baseUrl\n  if (baseUrl !== '/') {\n    baseUrl = baseUrl.replace(/\\/$/, '')\n  }\n  if (typeof studioUrl === 'string') {\n    return {baseUrl}\n  }\n  return {...studioUrl, baseUrl}\n}\n","import type {FilterDefault} from './types'\n\nexport const filterDefault: FilterDefault = ({sourcePath, value}) => {\n  // Skips encoding on URL or Date strings, similar to the `skip: 'auto'` parameter in vercelStegaCombine()\n  if (isValidDate(value) || isValidURL(value)) {\n    return false\n  }\n\n  const endPath = sourcePath.at(-1)\n  // Never encode slugs\n  if (sourcePath.at(-2) === 'slug' && endPath === 'current') {\n    return false\n  }\n\n  // Skip underscored keys, needs better heuristics but it works for now\n  if (typeof endPath === 'string' && endPath.startsWith('_')) {\n    return false\n  }\n\n  /**\n   * Best effort infer Portable Text paths that should not be encoded.\n   * Nothing is for certain, and the below implementation may cause paths that aren't Portable Text and otherwise be safe to encode to be skipped.\n   * However, that's ok as userland can always opt-in with the `encodeSourceMapAtPath` option and mark known safe paths as such, which will override this heuristic.\n   */\n  // If the path ends in marks[number] it's likely a PortableTextSpan: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#LL154C16-L154C16\n  if (typeof endPath === 'number' && sourcePath.at(-2) === 'marks') {\n    return false\n  }\n  // Or if it's [number].markDefs[number].href it's likely a PortableTextLink: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L163\n  if (\n    endPath === 'href' &&\n    typeof sourcePath.at(-2) === 'number' &&\n    sourcePath.at(-3) === 'markDefs'\n  ) {\n    return false\n  }\n  // Otherwise we have to deal with special properties of PortableTextBlock, and we can't confidently know if it's actually a `_type: 'block'` array item or not.\n  // All we know is that if it is indeed a block, and we encode the strings on these keys it'll for sure break the PortableText rendering and thus we skip encoding.\n  // https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L48-L58\n  if (endPath === 'style' || endPath === 'listItem') {\n    return false\n  }\n\n  // Don't encode into anything that is suggested it'll render for SEO in meta tags\n  if (\n    sourcePath.some(\n      (path) => path === 'meta' || path === 'metadata' || path === 'openGraph' || path === 'seo',\n    )\n  ) {\n    return false\n  }\n\n  // Finally, we ignore a bunch of paths that are typically used for page building\n  if (typeof endPath === 'string' && denylist.has(endPath)) {\n    return false\n  }\n\n  return true\n}\n\nconst denylist = new Set([\n  'color',\n  'colour',\n  'currency',\n  'email',\n  'format',\n  'gid',\n  'hex',\n  'href',\n  'hsl',\n  'hsla',\n  'icon',\n  'id',\n  'index',\n  'key',\n  'language',\n  'layout',\n  'link',\n  'linkAction',\n  'locale',\n  'lqip',\n  'page',\n  'path',\n  'ref',\n  'rgb',\n  'rgba',\n  'route',\n  'secret',\n  'slug',\n  'status',\n  'tag',\n  'template',\n  'theme',\n  'type',\n  'unit',\n  'url',\n  'username',\n  'variant',\n  'website',\n])\n\nfunction isValidDate(dateString: string) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false\n}\n\nfunction isValidURL(url: string) {\n  try {\n    new URL(url, url.startsWith('/') ? 'https://acme.com' : undefined)\n  } catch {\n    return false\n  }\n  return true\n}\n","import {vercelStegaCombine} from '@vercel/stega'\n\nimport {createEditUrl} from '../csm/createEditUrl'\nimport {jsonPathToStudioPath} from '../csm/jsonPath'\nimport {resolveStudioBaseRoute} from '../csm/resolveEditInfo'\nimport {reKeySegment, toString as studioPathToString} from '../csm/studioPath'\nimport {encodeIntoResult} from './encodeIntoResult'\nimport {filterDefault} from './filterDefault'\nimport {ContentSourceMap, ContentSourceMapParsedPath, InitializedStegaConfig} from './types'\n\nconst TRUNCATE_LENGTH = 20\n\n/**\n * Uses `@vercel/stega` to embed edit info JSON into strings in your query result.\n * The JSON payloads are added using invisible characters so they don't show up visually.\n * The edit info is generated from the Content Source Map (CSM) that is returned from Sanity for the query.\n * @public\n */\nexport function stegaEncodeSourceMap<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  config: InitializedStegaConfig,\n): Result {\n  const {filter, logger, enabled} = config\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\"\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  if (!resultSourceMap) {\n    logger?.error?.('[@sanity/client/stega]: Missing Content Source Map from response body', {\n      result,\n      resultSourceMap,\n      config,\n    })\n    return result\n  }\n\n  if (!config.studioUrl) {\n    const msg = 'config.studioUrl must be defined'\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  const report: Record<'encoded' | 'skipped', {path: string; length: number; value: string}[]> = {\n    encoded: [],\n    skipped: [],\n  }\n\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({sourcePath, sourceDocument, resultPath, value}) => {\n      // Allow userland to control when to opt-out of encoding\n      if (\n        (typeof filter === 'function'\n          ? filter({sourcePath, resultPath, filterDefault, sourceDocument, value})\n          : filterDefault({sourcePath, resultPath, filterDefault, sourceDocument, value})) === false\n      ) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: `${value.slice(0, TRUNCATE_LENGTH)}${\n              value.length > TRUNCATE_LENGTH ? '...' : ''\n            }`,\n            length: value.length,\n          })\n        }\n        return value\n      }\n\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? '...' : ''}`,\n          length: value.length,\n        })\n      }\n\n      const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n        typeof config.studioUrl === 'function'\n          ? config.studioUrl(sourceDocument)\n          : config.studioUrl!,\n      )\n      if (!baseUrl) return value\n      const {_id: id, _type: type} = sourceDocument\n\n      return vercelStegaCombine(\n        value,\n        {\n          origin: 'sanity.io',\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n          }),\n        },\n        // We use custom logic to determine if we should skip encoding\n        false,\n      )\n    },\n  )\n\n  if (logger) {\n    const isSkipping = report.skipped.length\n    const isEncoding = report.encoded.length\n    if (isSkipping || isEncoding) {\n      ;(logger?.groupCollapsed || logger.log)?.(\n        '[@sanity/client/stega]: Encoding source map into result',\n      )\n      logger.log?.(\n        `[@sanity/client/stega]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`,\n      )\n    }\n    if (report.encoded.length > 0) {\n      logger?.log?.(`[@sanity/client/stega]: Table of encoded paths`)\n      ;(logger?.table || logger.log)?.(report.encoded)\n    }\n    if (report.skipped.length > 0) {\n      const skipped = new Set<string>()\n      for (const {path} of report.skipped) {\n        skipped.add(path.replace(reKeySegment, '0').replace(/\\[\\d+\\]/g, '[]'))\n      }\n      logger?.log?.(`[@sanity/client/stega]: List of skipped paths`, [...skipped.values()])\n    }\n\n    if (isSkipping || isEncoding) {\n      logger?.groupEnd?.()\n    }\n  }\n\n  return resultWithStega\n}\n\nfunction prettyPathForLogging(path: ContentSourceMapParsedPath): string {\n  return studioPathToString(jsonPathToStudioPath(path))\n}\n"],"names":["parcelRequire","parcelRegister","$parcel$global","globalThis","self","window","global","register","module","exports","Object","defineProperty","get","$c64428117a1f496a$export$2b977f49f39a7e5e","set","s","enumerable","configurable","$do9pw","$cxjpp","$cv9Rk","$c6Xmf","$l0HdX","$lipNE","$c64428117a1f496a$var$reKeySegment","$c64428117a1f496a$var$toString","path","Array","isArray","Error","reduce","target","segment","i","segmentType","_","concat","$c64428117a1f496a$var$isKeySegment","test","trim","_key","_segment","from","to","JSON","stringify","$c64428117a1f496a$var$ESCAPE","$c64428117a1f496a$var$UNESCAPE","$c64428117a1f496a$var$parseJsonPath","match","parsed","parseRe","exec","key","replace","m","push","parseInt","_index","$c64428117a1f496a$var$jsonPathToStudioPath","map","$c64428117a1f496a$var$isRecord","value","$c64428117a1f496a$var$DRAFTS_PREFIX","$c64428117a1f496a$var$filterDefault","param","sourcePath","Date","parse","$c64428117a1f496a$var$isValidURL","url","URL","startsWith","e","endPath","at","some","$c64428117a1f496a$var$denylist","has","Set","freeze","__proto__","stegaEncodeSourceMap","result","resultSourceMap","config","filter","logger","enabled","msg","_a","error","call","TypeError","_b","studioUrl","msg1","_c","report","encoded","skipped","resultWithStega","encoder","baseUrl","sourceDocument","resultPath","filterDefault","slice","length","_resolveStudioBaseRoute","workspace","tool","id","_id","type","_type","b","origin","href","$c64428117a1f496a$var$createEditUrl","options","tmp","_workspace","tmp1","_tool","endsWith","stringifiedPath","searchParams","URLSearchParams","segments","routerParams","encodeURIComponent","join","$c64428117a1f496a$var$walkMap","mappingFn","arguments","v","idx","fromEntries","entries","_param","k","resolveMappingResult","$c64428117a1f496a$var$resolveMapping","csm","mappings","resultMappingPath","escapedKey","escapedKey1","mapping","matchedPath","pathSuffix","sort","param1","key1","key2","_param1","_mappings_","substring","source","documents","document","paths","matchPathSegments","sourcePathSegments","isSkipping","isEncoding","_d","groupCollapsed","log","_e","_f","_g","table","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_h","_i","_step","_iterator","Symbol","iterator","next","done","add","err","return","values","groupEnd","studioPath.toString","vercelStegaCombine","studioPathToString"],"version":3,"file":"stegaEncodeSourceMap-gZIRaYar.bbddeca9.js.map"}